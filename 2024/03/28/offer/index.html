<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>剑指offer | 陪小付度过漫长岁月</title><meta name="author" content="anym0re"><meta name="copyright" content="anym0re"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="JZ3 数组中重复的数字 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组[2,3,1,0,2,5,3]，那么对应的输出是2或者3。存在不合法的输入的话输出-1 1234567from collections import Counterclass">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer">
<meta property="og:url" content="http://anym0re.cn/2024/03/28/offer/index.html">
<meta property="og:site_name" content="陪小付度过漫长岁月">
<meta property="og:description" content="JZ3 数组中重复的数字 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组[2,3,1,0,2,5,3]，那么对应的输出是2或者3。存在不合法的输入的话输出-1 1234567from collections import Counterclass">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2024/02/25/zIWeRaZnF8Vxsqv.jpg">
<meta property="article:published_time" content="2024-03-28T02:44:52.000Z">
<meta property="article:modified_time" content="2025-07-10T14:12:27.166Z">
<meta property="article:author" content="anym0re">
<meta property="article:tag" content="代码">
<meta property="article:tag" content="python">
<meta property="article:tag" content="牛客">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2024/02/25/zIWeRaZnF8Vxsqv.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "剑指offer",
  "url": "http://anym0re.cn/2024/03/28/offer/",
  "image": "https://s2.loli.net/2024/02/25/zIWeRaZnF8Vxsqv.jpg",
  "datePublished": "2024-03-28T02:44:52.000Z",
  "dateModified": "2025-07-10T14:12:27.166Z",
  "author": [
    {
      "@type": "Person",
      "name": "anym0re",
      "url": "http://anym0re.cn"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://anym0re.cn/2024/03/28/offer/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="codeva-ofPgiBHacA"/><link rel="stylesheet" href="/css/index.css?v=5.4.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6b5bda8e65d88b63b357588907070664";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '剑指offer',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/url(https:/s2.loli.net/2024/02/25/twedroK7pS9vbIy.jpg));"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://s2.loli.net/2024/02/25/zIWeRaZnF8Vxsqv.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera"></i><span> 相册</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fas fa-comment"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(https://s2.loli.net/2024/02/25/twedroK7pS9vbIy.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://s2.loli.net/2024/02/25/AjqPFYabZUBO638.png" alt="Logo"><span class="site-name">陪小付度过漫长岁月</span></a><a class="nav-page-title" href="/"><span class="site-name">剑指offer</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera"></i><span> 相册</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fas fa-comment"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">剑指offer</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-28T02:44:52.000Z" title="发表于 2024-03-28 10:44:52">2024-03-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-10T14:12:27.166Z" title="更新于 2025-07-10 22:12:27">2025-07-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%BB%A3%E7%A0%81/">代码</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">13k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>57分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="JZ3-数组中重复的数字"><strong>JZ3</strong> 数组中重复的数字</h2>
<p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组[2,3,1,0,2,5,3]，那么对应的输出是2或者3。存在不合法的输入的话输出-1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">duplicate</span>(<span class="params">self , numbers: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        cnt = Counter(numbers)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> cnt[item] &gt; <span class="number">1</span>: <span class="keyword">return</span> item</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="JZ5-替换空格"><strong>JZ5</strong> 替换空格</h2>
<p>请实现一个函数，将一个字符串s中的每个空格替换成“%20”。</p>
<p>例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">replaceSpace</span>(<span class="params">self , s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        s = s.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;%20&#x27;</span>.join(s)</span><br></pre></td></tr></table></figure>
<h2 id="JZ6-从尾到头打印链表"><strong>JZ6</strong> 从尾到头打印链表</h2>
<p>输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#倒序，实质是栈思想</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printListFromTailToHead</span>(<span class="params">self , listNode: ListNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        lst = []</span><br><span class="line">        <span class="keyword">while</span> listNode:</span><br><span class="line">            lst.append(listNode.val)</span><br><span class="line">            listNode = listNode.<span class="built_in">next</span></span><br><span class="line">        lst.reverse()</span><br><span class="line">        <span class="keyword">return</span> lst</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#递归</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment">#设置递归深度</span></span><br><span class="line">sys.setrecursionlimit(<span class="number">100000</span>) </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursion</span>(<span class="params">self, head: ListNode, res: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        <span class="keyword">if</span> head:</span><br><span class="line">            <span class="comment">#先往链表深处遍历</span></span><br><span class="line">            <span class="variable language_">self</span>.recursion(head.<span class="built_in">next</span>, res) </span><br><span class="line">            <span class="comment">#再填充到数组就是逆序</span></span><br><span class="line">            res.append(head.val) </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printListFromTailToHead</span>(<span class="params">self , listNode: ListNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment">#递归函数打印</span></span><br><span class="line">        <span class="variable language_">self</span>.recursion(listNode, res) </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="JZ7-重建二叉树"><strong>JZ7</strong> 重建二叉树</h2>
<p>给定节点数为 n 的二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。</p>
<p>例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建出如下图所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reConstructBinaryTree</span>(<span class="params">self , preOrder: <span class="type">List</span>[<span class="built_in">int</span>], vinOrder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span><br><span class="line">        m, n = <span class="built_in">len</span>(preOrder), <span class="built_in">len</span>(vinOrder)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">        root = TreeNode(preOrder[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> vinOrder[i] == preOrder[<span class="number">0</span>]:</span><br><span class="line">                leftvin = vinOrder[:i]</span><br><span class="line">                rightvin = vinOrder[i+<span class="number">1</span>:]</span><br><span class="line">                leftpre = preOrder[<span class="number">1</span>:<span class="built_in">len</span>(leftvin)+<span class="number">1</span>]</span><br><span class="line">                rightpre = preOrder[<span class="built_in">len</span>(leftvin)+<span class="number">1</span>:]</span><br><span class="line">                root.left = <span class="variable language_">self</span>.reConstructBinaryTree(leftpre,leftvin)</span><br><span class="line">                root.right = <span class="variable language_">self</span>.reConstructBinaryTree(rightpre,rightvin)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#栈</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reConstructBinaryTree</span>(<span class="params">self , pre: <span class="type">List</span>[<span class="built_in">int</span>], vin: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span><br><span class="line">        n = <span class="built_in">len</span>(pre)</span><br><span class="line">        m = <span class="built_in">len</span>(vin)</span><br><span class="line">        <span class="comment"># 每个遍历都不能为0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> m == <span class="number">0</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        s = []</span><br><span class="line">        <span class="comment"># 首先建立前序第一个即根节点</span></span><br><span class="line">        root = TreeNode(pre[<span class="number">0</span>]) </span><br><span class="line">        cur = root</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># 要么旁边这个是它的左节点</span></span><br><span class="line">            <span class="keyword">if</span> cur.val != vin[j]: </span><br><span class="line">                cur.left = TreeNode(pre[i])</span><br><span class="line">                s.append(cur)</span><br><span class="line">                cur = cur.left </span><br><span class="line">            <span class="comment"># 要么旁边这个是它的右节点，或者祖先的右节点</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 弹出到符合的祖先</span></span><br><span class="line">                <span class="keyword">while</span> s <span class="keyword">and</span> s[-<span class="number">1</span>].val == vin[j]: </span><br><span class="line">                    cur = s[-<span class="number">1</span>]</span><br><span class="line">                    s.pop()</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 添加右节点</span></span><br><span class="line">                cur.right = TreeNode(pre[i]) </span><br><span class="line">                cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h2 id="JZ8-二叉树的下一个结点"><strong>JZ8</strong> 二叉树的下一个结点</h2>
<p>给定一个二叉树其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的next指针。下图为一棵有9个节点的二叉树。树中从父节点指向子节点的指针用实线表示，从子节点指向父节点的用虚线表示</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">GetNext</span>(<span class="params">self, pNode</span>):</span><br><span class="line">        <span class="keyword">if</span> pNode.right:</span><br><span class="line">            cur = pNode.right</span><br><span class="line">            <span class="keyword">while</span> cur.left: cur = cur.left</span><br><span class="line">            <span class="keyword">return</span> cur</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = pNode</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">and</span> cur.<span class="built_in">next</span>.right == cur: cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> cur.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<h2 id="JZ9-用两个栈实现队列"><strong>JZ9</strong> 用两个栈实现队列</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.stack1 = []</span><br><span class="line">        <span class="variable language_">self</span>.stack2 = []</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="variable language_">self</span>.stack1.append(node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.stack2:</span><br><span class="line">            <span class="keyword">while</span> <span class="variable language_">self</span>.stack1: <span class="variable language_">self</span>.stack2.append(<span class="variable language_">self</span>.stack1.pop())</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.stack2.pop()</span><br></pre></td></tr></table></figure>
<h2 id="JZ10-斐波那契数列"><strong>JZ10</strong> 斐波那契数列</h2>
<p>大家都知道斐波那契数列，现在要求输入一个正整数 n ，请你输出斐波那契数列的第 n 项。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Fibonacci</span>(<span class="params">self , n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>):</span><br><span class="line">            a, b = b, a+b</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure>
<h2 id="JZ11-旋转数组的最小数字"><strong>JZ11</strong> 旋转数组的最小数字</h2>
<p>有一个长度为 n 的非降序数组，比如[1,2,3,4,5]，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了[3,4,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minNumberInRotateArray</span>(<span class="params">self , nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            m = (l+r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] &gt; nums[r]: l = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[m] &lt; nums[r]: r = m</span><br><span class="line">            <span class="keyword">else</span>: r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums[r]</span><br></pre></td></tr></table></figure>
<h2 id="JZ12-矩阵中的路径"><strong>JZ12</strong> 矩阵中的路径</h2>
<p>请设计一个函数，用来判断在一个n乘m的矩阵中是否存在一条包含某长度为len的字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPath</span>(<span class="params">self , matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]], word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        m, n, flag = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>]), <span class="literal">False</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, j, k</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> flag</span><br><span class="line">            <span class="keyword">if</span> flag: <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> k == <span class="built_in">len</span>(word): </span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            visit[i][j] = <span class="literal">True</span> <span class="comment">#标记为已经过</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> visit[i-<span class="number">1</span>][j] <span class="keyword">and</span> matrix[i-<span class="number">1</span>][j] == word[k]: dfs(i-<span class="number">1</span>, j, k+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> i&lt;m-<span class="number">1</span> <span class="keyword">and</span> <span class="keyword">not</span> visit[i+<span class="number">1</span>][j] <span class="keyword">and</span> matrix[i+<span class="number">1</span>][j] == word[k]: dfs(i+<span class="number">1</span>, j, k+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> j&gt;<span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> visit[i][j-<span class="number">1</span>] <span class="keyword">and</span> matrix[i][j-<span class="number">1</span>] == word[k]: dfs(i, j-<span class="number">1</span>, k+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> j&lt;n-<span class="number">1</span> <span class="keyword">and</span> <span class="keyword">not</span> visit[i][j+<span class="number">1</span>] <span class="keyword">and</span> matrix[i][j+<span class="number">1</span>] == word[k]: dfs(i, j+<span class="number">1</span>, k+<span class="number">1</span>)</span><br><span class="line">            visit[i][j] = <span class="literal">False</span> <span class="comment">#无路可走，回退，消除标记</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                visit = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == word[<span class="number">0</span>]: dfs(i,j,<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> flag</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]], n: <span class="built_in">int</span>, m: <span class="built_in">int</span>, i: <span class="built_in">int</span>, j: <span class="built_in">int</span>, word: <span class="built_in">str</span>, k: <span class="built_in">int</span>, flag: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">bool</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= n <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= m <span class="keyword">or</span> (matrix[i][j] != word[k]) <span class="keyword">or</span> flag[i][j]:</span><br><span class="line">            <span class="comment">#下标越界、字符不匹配、已经遍历过不能重复</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment">#k为记录当前第几个字符</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="built_in">len</span>(word) - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        flag[i][j] = <span class="literal">True</span></span><br><span class="line">        <span class="comment">#该结点任意方向可行就可</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">self</span>.dfs(matrix, n, m, i - <span class="number">1</span>, j, word, k + <span class="number">1</span>, flag) </span><br><span class="line">            <span class="keyword">or</span> <span class="variable language_">self</span>.dfs(matrix, n, m, i + <span class="number">1</span>, j, word, k + <span class="number">1</span>, flag) </span><br><span class="line">            <span class="keyword">or</span> <span class="variable language_">self</span>.dfs(matrix, n, m, i, j - <span class="number">1</span>, word, k + <span class="number">1</span>, flag) </span><br><span class="line">            <span class="keyword">or</span> <span class="variable language_">self</span>.dfs(matrix, n, m, i , j + <span class="number">1</span>, word, k + <span class="number">1</span>, flag)):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">        <span class="comment">#没找到经过此格的，此格未被占用</span></span><br><span class="line">        flag[i][j] = <span class="literal">False</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPath</span>(<span class="params">self , matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]], word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        n = <span class="built_in">len</span>(matrix)</span><br><span class="line">        m = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="comment">#初始化flag矩阵记录是否走过</span></span><br><span class="line">        flag = [[<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (m)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="comment">#遍历矩阵找起点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                <span class="comment">#通过dfs找到路径</span></span><br><span class="line">                <span class="keyword">if</span> <span class="variable language_">self</span>.dfs(matrix, n, m, i, j, word, <span class="number">0</span>, flag):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h2 id="JZ13-机器人的运动范围"><strong>JZ13</strong> 机器人的运动范围</h2>
<p>地上有一个 rows 行和 cols 列的方格。坐标从 [0,0] 到 [rows-1,cols-1] 。一个机器人从坐标 [0,0] 的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 threshold 的格子。 例如，当 threshold 为 18 时，机器人能够进入方格  [35,37] ，因为 3+5+3+7 = 18。但是，它不能进入方格 [35,38] ，因为 3+5+3+8 = 19 。请问该机器人能够达到多少个格子？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">movingCount</span>(<span class="params">self , threshold: <span class="built_in">int</span>, rows: <span class="built_in">int</span>, cols: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i,j</span>):</span><br><span class="line">            <span class="keyword">if</span> i&lt;<span class="number">0</span> <span class="keyword">or</span> i&gt;=rows <span class="keyword">or</span> j&lt;<span class="number">0</span> <span class="keyword">or</span> j&gt;=cols <span class="keyword">or</span> visit[i][j] <span class="keyword">or</span> \</span><br><span class="line">               (i%<span class="number">10</span> + i//<span class="number">10</span> % <span class="number">10</span> + i//<span class="number">100</span> + j%<span class="number">10</span> + j//<span class="number">10</span> % <span class="number">10</span> + j//<span class="number">100</span>) &gt; threshold:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            visit[i][j] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> dfs(i-<span class="number">1</span>,j) + dfs(i+<span class="number">1</span>,j) + dfs(i,j-<span class="number">1</span>) + dfs(i,j+<span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">        visit = [[<span class="literal">False</span>] * cols <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(rows)]</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h2 id="JZ14-剪绳子"><strong>JZ14</strong> 剪绳子</h2>
<p>给你一根长度为 n 的绳子，请把绳子剪成整数长的 m 段（ m 、 n 都是整数， n &gt; 1 并且 m &gt; 1 ， m &lt;= n ），每段绳子的长度记为 k[1],…,k[m] 。请问 k[1]<em>k[2]</em>…*k[m] 可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> n &lt;= <span class="number">3</span>: <span class="keyword">return</span> n-<span class="number">1</span></span><br><span class="line">m, k = n // <span class="number">3</span>, n % <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> k == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">3</span>**m</span><br><span class="line"><span class="keyword">elif</span> k == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">3</span>**(m-<span class="number">1</span>)*<span class="number">4</span></span><br><span class="line"><span class="keyword">elif</span> k == <span class="number">2</span>: <span class="keyword">return</span> <span class="number">3</span>**m*<span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="JZ15-二进制中1的个数"><strong>JZ15</strong> 二进制中1的个数</h2>
<p>输入一个整数 n ，输出该数32位二进制表示中1的个数。其中负数用补码表示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">NumberOf1</span>(<span class="params">self , n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span>: res += <span class="number">1</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="JZ16-数值的整数次方"><strong>JZ16</strong> 数值的整数次方</h2>
<p>实现函数 double Power(double base, int exponent)，求base的exponent次方。</p>
<p>注意：</p>
<p>1.保证base和exponent不同时为0。</p>
<p>2.不得使用库函数，同时不需要考虑大数问题</p>
<p>3.有特殊判题，不用考虑小数点后面0的位数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Power</span>(<span class="params">self , base: <span class="built_in">float</span>, exponent: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> exponent &lt; <span class="number">0</span>:</span><br><span class="line">            base, exponent = <span class="number">1</span>/base, -exponent</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(exponent):</span><br><span class="line">            res *= base</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="JZ17-打印从1到最大的n位数"><strong>JZ17</strong> 打印从1到最大的n位数</h2>
<p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<ol>
<li>用返回一个整数列表来代替打印</li>
<li>n 为正整数，0 &lt; n &lt;= 5</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printNumbers</span>(<span class="params">self , n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>**n)]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="JZ18-删除链表的节点"><strong>JZ18</strong> 删除链表的节点</h2>
<p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。</p>
<p>1.此题对比原题有改动</p>
<p>2.题目保证链表中节点的值互不相同</p>
<p>3.该题只会输出返回的链表和结果做对比，所以若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self , head: ListNode, val: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> head.val == val: <span class="keyword">return</span> head.<span class="built_in">next</span> <span class="comment">#判断头节点</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span>.val != val: cur = cur.<span class="built_in">next</span></span><br><span class="line">        cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<h2 id="JZ20-表示数值的字符串"><strong>JZ20</strong> 表示数值的字符串</h2>
<p>请实现一个函数用来判断字符串str是否表示数值（包括科学计数法的数字，小数和整数）。</p>
<p><strong>科学计数法的数字</strong>(按顺序）可以分成以下几个部分:</p>
<p>1.若干空格</p>
<p>2.一个整数或者小数</p>
<p>3.（可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个整数(可正可负)</p>
<p>4.若干空格</p>
<p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p>
<p>1.若干空格</p>
<p>2.（可选）一个符号字符（‘+’ 或 ‘-’）</p>
<p>\3. 可能是以下描述格式之一:</p>
<p>3.1 至少一位数字，后面跟着一个点 ‘.’</p>
<p>3.2 至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字</p>
<p>3.3 一个点 ‘.’ ，后面跟着至少一位数字</p>
<p>4.若干空格</p>
<p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p>
<p>1.若干空格<br>
2.（可选）一个符号字符（‘+’ 或 ‘-’)</p>
<p>\3. 至少一位数字</p>
<p>4.若干空格</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#有限状态机</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isNumeric</span>(<span class="params">self , <span class="built_in">str</span> </span>):</span><br><span class="line">        state = [&#123;<span class="string">&#x27; &#x27;</span>:<span class="number">0</span>, <span class="string">&#x27;s&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;d&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;.&#x27;</span>:<span class="number">4</span>&#125;,</span><br><span class="line">                 &#123;<span class="string">&#x27;d&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;.&#x27;</span>:<span class="number">4</span>&#125;,</span><br><span class="line">                 &#123;<span class="string">&#x27;d&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;.&#x27;</span>:<span class="number">3</span>, <span class="string">&#x27;e&#x27;</span>:<span class="number">5</span>, <span class="string">&#x27; &#x27;</span>:<span class="number">8</span>&#125;,</span><br><span class="line">                 &#123;<span class="string">&#x27;d&#x27;</span>:<span class="number">3</span>, <span class="string">&#x27;e&#x27;</span>:<span class="number">5</span>, <span class="string">&#x27; &#x27;</span>:<span class="number">8</span>&#125;,</span><br><span class="line">                 &#123;<span class="string">&#x27;d&#x27;</span>:<span class="number">3</span>&#125;,</span><br><span class="line">                 &#123;<span class="string">&#x27;s&#x27;</span>:<span class="number">6</span>, <span class="string">&#x27;d&#x27;</span>:<span class="number">7</span>&#125;,</span><br><span class="line">                 &#123;<span class="string">&#x27;d&#x27;</span>:<span class="number">7</span>&#125;,</span><br><span class="line">                 &#123;<span class="string">&#x27;d&#x27;</span>:<span class="number">7</span>, <span class="string">&#x27; &#x27;</span>:<span class="number">8</span>&#125;,</span><br><span class="line">                 &#123;<span class="string">&#x27; &#x27;</span>:<span class="number">8</span>&#125;]</span><br><span class="line">        p = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;0&#x27;</span> &lt;= c &lt;= <span class="string">&#x27;9&#x27;</span>: t = <span class="string">&#x27;d&#x27;</span></span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">&#x27;+-&#x27;</span>: t = <span class="string">&#x27;s&#x27;</span></span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">&#x27;Ee&#x27;</span>: t = <span class="string">&#x27;e&#x27;</span></span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">&#x27;. &#x27;</span>: t = c</span><br><span class="line">            <span class="keyword">else</span>: t = <span class="string">&#x27;?&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> t <span class="keyword">not</span> <span class="keyword">in</span> state[p]: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            p = state[p][t]</span><br><span class="line">        <span class="keyword">return</span> p <span class="keyword">in</span> [<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br></pre></td></tr></table></figure>
<h2 id="JZ21-调整数组顺序使奇数位于偶数前面-一"><strong>JZ21</strong> 调整数组顺序使奇数位于偶数前面(一)</h2>
<p>输入一个长度为 n 整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前面部分，所有的偶数位于数组的后面部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#时间O(N),空间O(N)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reOrderArray</span>(<span class="params">self , array: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        odd, even = [], []</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">if</span> m % <span class="number">2</span>: odd.append(m)</span><br><span class="line">            <span class="keyword">else</span>: even.append(m)</span><br><span class="line">        <span class="keyword">return</span> odd + even</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#时间O(N2),空间O(1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reOrderArray</span>(<span class="params">self , array: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(array):</span><br><span class="line">            <span class="keyword">if</span> array[i] % <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">while</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> array[i-<span class="number">1</span>] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    array[i-<span class="number">1</span>], array[i] = array[i], array[i-<span class="number">1</span>]</span><br><span class="line">                    i -= <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure>
<h2 id="JZ22-链表中倒数最后k个结点"><strong>JZ22</strong> 链表中倒数最后k个结点</h2>
<p>输入一个长度为 n 的链表，设链表中的元素的值为 ai ，返回该链表中倒数第k个节点。</p>
<p>如果该链表长度小于k，请返回一个长度为 0 的链表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#单指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">FindKthToTail</span>(<span class="params">self , pHead: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        node_num = <span class="number">0</span></span><br><span class="line">        cur = pHead</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            node_num += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> node_num &lt; k: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(node_num-k): pHead = pHead.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> pHead</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#双指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">FindKthToTail</span>(<span class="params">self , pHead: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        cur = pHead</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            pHead = pHead.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> pHead</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#栈</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">FindKthToTail</span>(<span class="params">self , pHead: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">while</span> pHead:</span><br><span class="line">            stk.append(pHead)</span><br><span class="line">            pHead = pHead.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(stk) &lt; k: <span class="keyword">return</span></span><br><span class="line">        cur = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            cur = stk.pop()</span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>
<h2 id="JZ23-链表中环的入口结点"><strong>JZ23</strong> 链表中环的入口结点</h2>
<p>给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">EntryNodeOfLoop</span>(<span class="params">self, pHead</span>):</span><br><span class="line">        fast = slow = pHead</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>: <span class="comment">#快慢指针</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> fast == slow: </span><br><span class="line">                fast = pHead <span class="comment">#将快指针移到头结点，一起走a步到入口处</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">while</span> fast != slow:</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> fast </span><br></pre></td></tr></table></figure>
<h2 id="JZ24-反转链表">JZ24 反转链表</h2>
<p>给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ReverseList</span>(<span class="params">self , head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        pre, tmp =  <span class="literal">None</span>, head</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">            tmp.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = tmp</span><br><span class="line">            tmp = head</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>
<h2 id="JZ25-合并两个排序的链表"><strong>JZ25</strong> 合并两个排序的链表</h2>
<p>输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Merge</span>(<span class="params">self , pHead1: ListNode, pHead2: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead1 <span class="keyword">and</span> <span class="keyword">not</span> pHead2:<span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead2: <span class="keyword">return</span> pHead1</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead1: <span class="keyword">return</span> pHead2</span><br><span class="line">        <span class="keyword">if</span> pHead1.val &gt; pHead2.val: pHead1, pHead2 = pHead2, pHead1 <span class="comment">#保持1链条头节点更小</span></span><br><span class="line">        pre = cur = pHead1</span><br><span class="line">        pHead1 = pHead1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> pHead1 <span class="keyword">or</span> pHead2:</span><br><span class="line">            <span class="keyword">if</span> pHead1 <span class="keyword">and</span> (<span class="keyword">not</span> pHead2 <span class="keyword">or</span> pHead1.val &lt;= pHead2.val):</span><br><span class="line">                cur.<span class="built_in">next</span> = pHead1</span><br><span class="line">                pHead1 = pHead1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">elif</span> pHead2 <span class="keyword">and</span> (<span class="keyword">not</span> pHead1 <span class="keyword">or</span> pHead1.val &gt; pHead2.val):</span><br><span class="line">                cur.<span class="built_in">next</span> = pHead2</span><br><span class="line">                pHead2 = pHead2.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>
<h2 id="JZ26-树的子结构"><strong>JZ26</strong> 树的子结构</h2>
<p>输入两棵二叉树A，B，判断B是不是A的子结构。（我们约定空树不是任意一个树的子结构）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recur</span>(<span class="params">self,a,b</span>): <span class="comment">#判断同根树b是否为a的子结构</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> b: <span class="keyword">return</span> <span class="literal">True</span> <span class="comment">#如果b为空，则b过了叶层，返回True</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> a <span class="keyword">or</span> a.val != b.val: <span class="keyword">return</span> <span class="literal">False</span> <span class="comment">#如果a为空b不为空，则a过了叶层b没有，返回False</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="variable language_">self</span>.recur(a.left,b.left) <span class="keyword">and</span> <span class="variable language_">self</span>.recur(a.right,b.right) <span class="comment">#都不为空递归左右子树</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">HasSubtree</span>(<span class="params">self , pRoot1: TreeNode, pRoot2: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bool</span>(pRoot1 <span class="keyword">and</span> pRoot2) <span class="keyword">and</span> (<span class="variable language_">self</span>.recur(pRoot1, pRoot2) <span class="keyword">or</span> \</span><br><span class="line">               <span class="variable language_">self</span>.HasSubtree(pRoot1.left, pRoot2) <span class="keyword">or</span> <span class="variable language_">self</span>.HasSubtree(pRoot1.right, pRoot2))</span><br></pre></td></tr></table></figure>
<h2 id="JZ27-二叉树的镜像"><strong>JZ27</strong> 二叉树的镜像</h2>
<p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Mirror</span>(<span class="params">self , pRoot: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            root.left, root.right = root.right, root.left</span><br><span class="line">            dfs(root.left)</span><br><span class="line">            dfs(root.right)</span><br><span class="line">        dfs(pRoot)</span><br><span class="line">        <span class="keyword">return</span> pRoot</span><br></pre></td></tr></table></figure>
<h2 id="JZ29-顺时针打印矩阵"><strong>JZ29</strong> 顺时针打印矩阵</h2>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># matrix类型为二维列表，需要返回列表</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printMatrix</span>(<span class="params">self, matrix</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix: <span class="keyword">return</span> []</span><br><span class="line">        l, r, t, b = <span class="number">0</span>, <span class="built_in">len</span>(matrix[<span class="number">0</span>])-<span class="number">1</span>, <span class="number">0</span>, <span class="built_in">len</span>(matrix)-<span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        i = j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(l,r+<span class="number">1</span>): res.append(matrix[i][j])</span><br><span class="line">            t += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> t &gt; b: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(t,b+<span class="number">1</span>): res.append(matrix[i][j])</span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> l &gt; r: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(r,l-<span class="number">1</span>,-<span class="number">1</span>): res.append(matrix[i][j])</span><br><span class="line">            b -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> t &gt; b: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(b,t-<span class="number">1</span>,-<span class="number">1</span>): res.append(matrix[i][j])</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> l &gt; r: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="JZ30-包含min函数的栈"><strong>JZ30</strong> 包含min函数的栈</h2>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的 min 函数，输入操作时保证 pop、top 和 min 函数操作时，栈中一定有元素。</p>
<p>此栈包含的方法有：</p>
<p>push(value):将value压入栈中</p>
<p>pop():弹出栈顶元素</p>
<p>top():获取栈顶元素</p>
<p>min():获取栈中最小元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.stk = []</span><br><span class="line">        <span class="variable language_">self</span>.min_stk = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="variable language_">self</span>.stk.append(node)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.min_stk <span class="keyword">or</span> node &lt;= <span class="variable language_">self</span>.min_stk[-<span class="number">1</span>]: <span class="variable language_">self</span>.min_stk.append(node)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.min_stk[-<span class="number">1</span>] == <span class="variable language_">self</span>.stk[-<span class="number">1</span>]: <span class="variable language_">self</span>.min_stk.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.stk.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.stk[-<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">min</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.min_stk[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="JZ31-栈的压入、弹出序列"><strong>JZ31</strong> 栈的压入、弹出序列</h2>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。</p>
<ol>
<li>
<p>0&lt;=pushV.length == popV.length &lt;=1000</p>
</li>
<li>
<p>-1000&lt;=pushV[i]&lt;=1000</p>
</li>
<li>
<p>pushV 的所有数字均不相同</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">IsPopOrder</span>(<span class="params">self , pushV: <span class="type">List</span>[<span class="built_in">int</span>], popV: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        stk, i = [], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> pushV:</span><br><span class="line">            stk.append(num)</span><br><span class="line">            <span class="keyword">while</span> stk <span class="keyword">and</span> stk[-<span class="number">1</span>] == popV[i]:</span><br><span class="line">                stk.pop()</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stk</span><br></pre></td></tr></table></figure>
<h2 id="JZ32-从上往下打印二叉树"><strong>JZ32</strong> 从上往下打印二叉树</h2>
<p>不分行从上往下打印出二叉树的每个节点，同层节点从左至右打印。例如输入{8,6,10,#,#,2,1}，如以下图中的示例二叉树，则依次打印8,6,10,2,1(空节点不打印，跳过)，请你将打印的结果存放到一个数组里面，返回。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">PrintFromTopToBottom</span>(<span class="params">self , root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment">#BFS</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        queue, res = deque([root]), []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left: queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right: queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="JZ33-二叉搜索树的后序遍历序列"><strong>JZ33</strong> 二叉搜索树的后序遍历序列</h2>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回 true ,否则返回 false 。假设输入的数组的任意两个数字都互不相同</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">VerifySquenceOfBST</span>(<span class="params">self , sequence: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment">#分治思想</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> sequence: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">recur</span>(<span class="params">sequence</span>):</span><br><span class="line">            n = <span class="built_in">len</span>(sequence)</span><br><span class="line">            <span class="keyword">if</span> n &lt;= <span class="number">2</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            p = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> sequence[p] &lt; sequence[-<span class="number">1</span>]: p += <span class="number">1</span></span><br><span class="line">            m = p</span><br><span class="line">            <span class="keyword">while</span> sequence[p] &gt; sequence[-<span class="number">1</span>]: p += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> p == n-<span class="number">1</span> <span class="keyword">and</span> recur(sequence[:m]) <span class="keyword">and</span> recur(sequence[m:n-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> recur(sequence)</span><br></pre></td></tr></table></figure>
<h2 id="JZ35-复杂链表的复制"><strong>JZ35</strong> 复杂链表的复制</h2>
<p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）。 下图是一个含有5个结点的复杂链表。图中实线箭头表示next指针，虚线箭头表示random指针。为简单起见，指向null的指针没有画出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 返回 RandomListNode</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Clone</span>(<span class="params">self, pHead</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead: <span class="keyword">return</span></span><br><span class="line">        pre = cur = RandomListNode(pHead.label) <span class="comment">#pre作为头节点，cur复制pHead</span></span><br><span class="line">        ran = pHead <span class="comment">#加上随机指针</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            pHead = pHead.<span class="built_in">next</span></span><br><span class="line">            ran = ran.random</span><br><span class="line">            <span class="keyword">if</span> pHead: </span><br><span class="line">                tmp = RandomListNode(pHead.label)</span><br><span class="line">                cur.<span class="built_in">next</span> = tmp</span><br><span class="line">            <span class="keyword">else</span>: cur.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> ran:</span><br><span class="line">                tmp = RandomListNode(ran.label)</span><br><span class="line">                cur.random = tmp</span><br><span class="line">            <span class="keyword">else</span>: cur.random = <span class="literal">None</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            ran = pHead</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>
<h2 id="JZ36-二叉搜索树与双向链表"><strong>JZ36</strong> 二叉搜索树与双向链表</h2>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Convert</span>(<span class="params">self , pRootOfTree </span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">cur</span>): <span class="comment">#中序遍历</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">return</span></span><br><span class="line">            dfs(cur.left)</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.pre:</span><br><span class="line">                <span class="variable language_">self</span>.pre.right = cur</span><br><span class="line">                cur.left = <span class="variable language_">self</span>.pre</span><br><span class="line">            <span class="keyword">else</span>: <span class="variable language_">self</span>.head = cur <span class="comment">#头节点</span></span><br><span class="line">            <span class="variable language_">self</span>.pre = cur</span><br><span class="line">            dfs(cur.right)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRootOfTree: <span class="keyword">return</span></span><br><span class="line">        <span class="variable language_">self</span>.pre = <span class="literal">None</span> <span class="comment">#前节点</span></span><br><span class="line">        dfs(pRootOfTree)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.head</span><br></pre></td></tr></table></figure>
<h2 id="JZ37-序列化二叉树"><strong>JZ37</strong> 序列化二叉树</h2>
<p>请实现两个函数，分别用来序列化和反序列化二叉树，不对序列化之后的字符串进行约束，但要求能够根据序列化之后的字符串重新构造出一棵与原二叉树相同的树。</p>
<p>二叉树的序列化(Serialize)是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树等遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#）</p>
<p>二叉树的反序列化(Deserialize)是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Serialize</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        queue, res = deque([root]), []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                res.append(<span class="built_in">str</span>(node.val))</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            <span class="keyword">else</span>: queue.append(<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(res)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Deserialize</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span></span><br><span class="line">        s, i = s.split(), <span class="number">1</span></span><br><span class="line">        root = TreeNode(<span class="built_in">int</span>(s[<span class="number">0</span>]))</span><br><span class="line">        queue = deque([root])</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> s[i] != <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                node.left = TreeNode(<span class="built_in">int</span>(s[i]))</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[i] != <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                node.right = TreeNode(<span class="built_in">int</span>(s[i]))</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h2 id="JZ38-字符串的排列"><strong>JZ38</strong> 字符串的排列</h2>
<p>输入一个长度为 n 字符串，打印出该字符串中字符的所有排列，你可以以任意顺序返回这个字符串数组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Permutation</span>(<span class="params">self , <span class="built_in">str</span>: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">if</span> x == <span class="built_in">len</span>(<span class="built_in">str</span>)-<span class="number">1</span>:</span><br><span class="line">                res.append(<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">str</span>))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dic = <span class="built_in">set</span>() <span class="comment">#防止重复</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x,<span class="built_in">len</span>(<span class="built_in">str</span>)):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">str</span>[i] <span class="keyword">in</span> dic: <span class="keyword">continue</span> <span class="comment">#重复则跳过</span></span><br><span class="line">                dic.add(<span class="built_in">str</span>[i]) </span><br><span class="line">                <span class="built_in">str</span>[x], <span class="built_in">str</span>[i] = <span class="built_in">str</span>[i], <span class="built_in">str</span>[x] <span class="comment">#交换,把i固定在x位</span></span><br><span class="line">                dfs(x+<span class="number">1</span>) <span class="comment">#递归后续</span></span><br><span class="line">                <span class="built_in">str</span>[x], <span class="built_in">str</span>[i] = <span class="built_in">str</span>[i], <span class="built_in">str</span>[x] <span class="comment">#还原</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="built_in">str</span> = <span class="built_in">list</span>(<span class="built_in">str</span>)</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="JZ39-数组中出现次数超过一半的数字"><strong>JZ39</strong> 数组中出现次数超过一半的数字</h2>
<p>给一个长度为 n 的数组，数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>
<p>例如输入一个长度为9的数组[1,2,3,2,2,2,5,4,2]。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">MoreThanHalfNum_Solution</span>(<span class="params">self , numbers: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res, cnt = -<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> numbers:<span class="comment">#抵消法</span></span><br><span class="line">            <span class="keyword">if</span> cnt == <span class="number">0</span>: res = num</span><br><span class="line">            <span class="keyword">if</span> num == res: cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: cnt -= <span class="number">1</span>           </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="JZ40-最小的K个数"><strong>JZ40</strong> 最小的K个数</h2>
<p>给定一个长度为 n 的可能有重复值的数组，找出其中不去重的最小的 k 个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4(任意顺序皆可)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#堆</span></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">GetLeastNumbers_Solution</span>(<span class="params">self , <span class="built_in">input</span>: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        heapq.heapify(<span class="built_in">input</span>)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            res.append(heapq.heappop(<span class="built_in">input</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="JZ41-数据流中的中位数"><strong>JZ41</strong> 数据流中的中位数</h2>
<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.large = [] <span class="comment">#用最小堆储存大数</span></span><br><span class="line">        <span class="variable language_">self</span>.small = [] <span class="comment">#用最大堆储存小数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Insert</span>(<span class="params">self, num</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.large: <span class="variable language_">self</span>.large.append(num)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.large) &gt; <span class="built_in">len</span>(<span class="variable language_">self</span>.small):</span><br><span class="line">            heapq.heappush(<span class="variable language_">self</span>.small, -heapq.heappushpop(<span class="variable language_">self</span>.large, num))</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.large) == <span class="built_in">len</span>(<span class="variable language_">self</span>.small):</span><br><span class="line">            heapq.heappush(<span class="variable language_">self</span>.large, -heapq.heappushpop(<span class="variable language_">self</span>.small, -num))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">GetMedian</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.large) &gt; <span class="built_in">len</span>(<span class="variable language_">self</span>.small): <span class="keyword">return</span> <span class="variable language_">self</span>.large[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> (<span class="variable language_">self</span>.large[<span class="number">0</span>] -<span class="variable language_">self</span>.small[<span class="number">0</span>]) / <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="JZ43-整数中1出现的次数（从1到n整数中1出现的次数）">JZ43 整数中1出现的次数（从1到n整数中1出现的次数）</h2>
<p>输入一个整数 n ，求 1～n 这 n 个整数的十进制表示中 1 出现的次数<br>
例如， 1~13 中包含 1 的数字有 1 、 10 、 11 、 12 、 13 因此共出现 6 次</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#暴力求解 时间 nlog_10(n) 空间 1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">NumberOf1Between1AndN_Solution</span>(<span class="params">self, n</span>):</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>): </span><br><span class="line">            <span class="keyword">while</span> num:</span><br><span class="line">                <span class="keyword">if</span> num % <span class="number">10</span> == <span class="number">1</span>: res += <span class="number">1</span></span><br><span class="line">                num //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#数位求解</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">NumberOf1Between1AndN_Solution</span>(<span class="params">self, n</span>):</span><br><span class="line">        digit, res = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        h, c, l = n//<span class="number">10</span>, n%<span class="number">10</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> h <span class="keyword">or</span> c:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="number">0</span>: res += h * digit</span><br><span class="line">            <span class="keyword">elif</span> c == <span class="number">1</span>: res += h * digit + l + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: res += (h+<span class="number">1</span>) * digit</span><br><span class="line">            l += c * digit</span><br><span class="line">            c = h % <span class="number">10</span></span><br><span class="line">            h //= <span class="number">10</span></span><br><span class="line">            digit *= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="JZ44-数字序列中某一位的数字"><strong>JZ44</strong> 数字序列中某一位的数字</h2>
<p>数字以 0123456789101112131415… 的格式作为一个字符序列，在这个序列中第 2 位（<strong>从下标 0 开始计算</strong>）是 2 ，第 10 位是 1 ，第 13 位是 1 ，以此类题，请你输出第 n 位对应的数字。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findNthDigit</span>(<span class="params">self , n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res, digit = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> res &lt; n:</span><br><span class="line">            digit += <span class="number">1</span></span><br><span class="line">            res += <span class="number">9</span> * digit * <span class="number">10</span>**(digit-<span class="number">1</span>)</span><br><span class="line">        x, y = (res-n) // digit, (res-n) % digit</span><br><span class="line">        pur =  <span class="number">10</span>**digit - x - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(<span class="built_in">str</span>(pur)[-<span class="number">1</span>-y])</span><br></pre></td></tr></table></figure>
<h2 id="JZ45-把数组排成最小的数"><strong>JZ45</strong> 把数组排成最小的数</h2>
<p>输入一个非负整数数组numbers，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<p>例如输入数组[3，32，321]，则打印出这三个数字能排成的最小数字为321323。</p>
<p>1.输出结果可能非常大，所以你需要返回一个字符串而不是整数<br>
2.拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#冒泡排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">PrintMinNumber</span>(<span class="params">self , numbers: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(numbers)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            numbers[k] = <span class="built_in">str</span>(numbers[k])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-i-<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">int</span>(numbers[j]+numbers[j+<span class="number">1</span>]) &gt; <span class="built_in">int</span>(numbers[j+<span class="number">1</span>]+numbers[j]):</span><br><span class="line">                    numbers[j], numbers[j+<span class="number">1</span>] = numbers[j+<span class="number">1</span>], numbers[j]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(numbers)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#匿名函数</span></span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">PrintMinNumber</span>(<span class="params">self , numbers: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment">#空数组的情况</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="comment">#将数字转成字符</span></span><br><span class="line">        nums = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>, numbers))</span><br><span class="line">        <span class="comment">#重载比较大小</span></span><br><span class="line">        cmp = <span class="keyword">lambda</span> a, b: <span class="number">1</span> <span class="keyword">if</span> a + b &gt; b + a <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment">#排序</span></span><br><span class="line">        nums.sort(key = functools.cmp_to_key(cmp))</span><br><span class="line">        <span class="comment">#字符串叠加</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(nums)</span><br></pre></td></tr></table></figure>
<h2 id="JZ46-把数字翻译成字符串"><strong>JZ46</strong> 把数字翻译成字符串</h2>
<p>有一种将字母编码成数字的方式：‘a’-&gt;1, ‘b-&gt;2’, … , ‘z-&gt;26’。</p>
<p>现在给一串数字，返回有多少种可能的译码结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">self , nums: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums = <span class="string">&#x27;0&#x27;</span> + nums</span><br><span class="line">        dp = [<span class="number">0</span>] * (<span class="built_in">len</span>(nums))</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[i-<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;12&#x27;</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>: dp[i] = dp[i-<span class="number">2</span>]</span><br><span class="line">                <span class="keyword">continue</span>   </span><br><span class="line">            <span class="keyword">if</span> <span class="number">11</span> &lt;= <span class="built_in">int</span>(nums[i-<span class="number">1</span>:i+<span class="number">1</span>]) &lt;= <span class="number">26</span>:</span><br><span class="line">                dp[i] = dp[i-<span class="number">2</span>] + dp[i-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>: dp[i] = dp[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="JZ47-礼物的最大价值"><strong>JZ47</strong> 礼物的最大价值</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxValue</span>(<span class="params">self , grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-<span class="number">1</span>] + grid[<span class="number">0</span>][j]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m):</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]) + grid[i][j]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="JZ48-最长不含重复字符的子字符串"><strong>JZ48</strong> 最长不含重复字符的子字符串</h2>
<p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#动态规划字符串</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self , s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="string">&#x27;&#x27;</span>] * <span class="built_in">len</span>(s)</span><br><span class="line">        dp[<span class="number">0</span>] = s[<span class="number">0</span>]</span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> dp[i-<span class="number">1</span>]:</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>][dp[i-<span class="number">1</span>].find(s[i])+<span class="number">1</span>:] + s[i]</span><br><span class="line">            <span class="keyword">else</span>: dp[i] = dp[i-<span class="number">1</span>] + s[i]</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">len</span>(dp[i]))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#动态规划+哈希表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self , s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] * <span class="built_in">len</span>(s)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        mp = &#123;s[<span class="number">0</span>]:<span class="number">0</span>&#125;</span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">not</span> <span class="keyword">in</span> mp:</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i-<span class="number">1</span>] + <span class="number">1</span>, i - mp[s[i]])</span><br><span class="line">            mp[s[i]] = i</span><br><span class="line">            res = <span class="built_in">max</span>(res, dp[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#滑动窗口+哈希表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self , s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        i = j = <span class="number">0</span></span><br><span class="line">        mp = &#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">if</span> s[j] <span class="keyword">in</span> mp:</span><br><span class="line">                mp[s[j]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: mp[s[j]] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> mp[s[j]] &gt; <span class="number">1</span>:</span><br><span class="line">                mp[s[i]] -= <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, j - i + <span class="number">1</span>)</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="JZ49-丑数"><strong>JZ49</strong> 丑数</h2>
<p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第 n个丑数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">GetUglyNumber_Solution</span>(<span class="params">self , index: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">1</span>] * (index)</span><br><span class="line">        a = b = c = <span class="number">0</span> <span class="comment">#三个指针对应乘2、3、5</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,index):</span><br><span class="line">            n2, n3, n5 = <span class="number">2</span>*dp[a], <span class="number">3</span>*dp[b], <span class="number">5</span>*dp[c]</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(n2, n3, n5)</span><br><span class="line">            <span class="keyword">if</span> dp[i] == n2: a += <span class="number">1</span> <span class="comment">#说明没有其他情况更小，所以指针前进一位</span></span><br><span class="line">            <span class="keyword">if</span> dp[i] == n3: b += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> dp[i] == n5: c += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#哈希表 时间N，空间N</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">FirstNotRepeatingChar</span>(<span class="params">self , <span class="built_in">str</span>: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        mp = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">            <span class="keyword">if</span> s <span class="keyword">not</span> <span class="keyword">in</span> mp: mp[s] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: mp[s] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">str</span>)):</span><br><span class="line">            <span class="keyword">if</span> mp[<span class="built_in">str</span>[i]] == <span class="number">1</span>: <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>   </span><br><span class="line">    </span><br><span class="line"><span class="comment">#Counter 时间N，空间N</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">FirstNotRepeatingChar</span>(<span class="params">self , <span class="built_in">str</span>: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        cnt = Counter(<span class="built_in">str</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">str</span>)):</span><br><span class="line">            <span class="keyword">if</span> cnt[<span class="built_in">str</span>[i]] == <span class="number">1</span>: <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>    </span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#暴力，时间N2，空间N，如果用哈希表储存位置的话，时间同样是N</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">FirstNotRepeatingChar</span>(<span class="params">self , <span class="built_in">str</span>: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        rec = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">str</span>)):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">str</span>[i] <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span>[i+<span class="number">1</span>:] <span class="keyword">and</span> <span class="built_in">str</span>[i] <span class="keyword">not</span> <span class="keyword">in</span> rec: <span class="keyword">return</span> i</span><br><span class="line">            <span class="keyword">else</span>: rec.add(<span class="built_in">str</span>[i])</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="JZ51-数组中的逆序对"><strong>JZ51</strong> 数组中的逆序对</h2>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P mod 1000000007</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>: <span class="comment">#归并排序</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">InversePairs</span>(<span class="params">self , nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">mergesort</span>(<span class="params">l,r</span>):</span><br><span class="line">            <span class="keyword">if</span> l &gt;= r: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            m = (l+r) // <span class="number">2</span></span><br><span class="line">            res = mergesort(l,m) + mergesort(m+<span class="number">1</span>,r)</span><br><span class="line">            tmp = nums[l:r+<span class="number">1</span>]</span><br><span class="line">            i, j = <span class="number">0</span>, m-l+<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(l,r+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i == m-l+<span class="number">1</span>:</span><br><span class="line">                    nums[k] = tmp[j]</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> j == r-l+<span class="number">1</span> <span class="keyword">or</span> tmp[i] &lt;= tmp[j]:</span><br><span class="line">                    nums[k] = tmp[i]</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    nums[k] = tmp[j]</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    res = (res + m-l-i+<span class="number">1</span>) % <span class="number">1_000_000_007</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> mergesort(<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="JZ52-两个链表的第一个公共结点"><strong>JZ52</strong> 两个链表的第一个公共结点</h2>
<p>输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#都走一遍，看看长度，然后再找节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">FindFirstCommonNode</span>(<span class="params">self , pHead1 , pHead2 </span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead1 <span class="keyword">or</span> <span class="keyword">not</span> pHead2: <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> root.<span class="built_in">next</span>:</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">                root = root.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        gap = dfs(pHead1) - dfs(pHead2)</span><br><span class="line">        <span class="keyword">if</span> gap &lt; <span class="number">0</span>: pHead1, pHead2 = pHead2, pHead1</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">abs</span>(gap)):</span><br><span class="line">            pHead1 = pHead1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> pHead1 <span class="keyword">and</span> pHead2 <span class="keyword">and</span> pHead1 != pHead2:</span><br><span class="line">            pHead1 = pHead1.<span class="built_in">next</span></span><br><span class="line">            pHead2 = pHead2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> pHead1</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#哈希表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">FindFirstCommonNode</span>(<span class="params">self , pHead1 , pHead2 </span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead1 <span class="keyword">or</span> <span class="keyword">not</span> pHead2: <span class="keyword">return</span></span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">while</span> pHead1:</span><br><span class="line">            stk.append(pHead1)</span><br><span class="line">            pHead1 = pHead1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> pHead2:</span><br><span class="line">            <span class="keyword">if</span> pHead2 <span class="keyword">in</span> stk: <span class="keyword">break</span></span><br><span class="line">            pHead2 = pHead2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> pHead2</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#双指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">FindFirstCommonNode</span>(<span class="params">self , pHead1 , pHead2 </span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead1 <span class="keyword">or</span> <span class="keyword">not</span> pHead2: <span class="keyword">return</span></span><br><span class="line">        cur1, cur2 = pHead1, pHead2</span><br><span class="line">        <span class="keyword">while</span> cur1 != cur2:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur1: cur1 = pHead2</span><br><span class="line">            <span class="keyword">else</span>: cur1 = cur1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur2: cur2 = pHead1</span><br><span class="line">            <span class="keyword">else</span>: cur2 = cur2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> cur1</span><br></pre></td></tr></table></figure>
<p><strong>JZ53</strong> <strong>数字在升序数组中出现的次数</strong></p>
<p>给定一个长度为 n 的非降序数组和一个非负数整数 k ，要求统计 k 在数组中出现的次数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用bisect_left</span></span><br><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">GetNumberOfK</span>(<span class="params">self , nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> bisect.bisect(nums,k) - bisect.bisect_left(nums,k)</span><br><span class="line"></span><br><span class="line"><span class="comment">#直接找比k-0.5大的</span></span><br><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">GetNumberOfK</span>(<span class="params">self , nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> bisect.bisect(nums,k) - bisect.bisect(nums,k-<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">GetNumberOfK</span>(<span class="params">self , nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[<span class="number">0</span>] == k: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            m = (l+r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] &lt; k + <span class="number">0.5</span>: l = m+<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[m] &gt; k + <span class="number">0.5</span>: r = m-<span class="number">1</span></span><br><span class="line">        j = l</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            m = (l+r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] &lt; k - <span class="number">0.5</span>: l = m+<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[m] &gt; k - <span class="number">0.5</span>: r = m-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> j - l</span><br></pre></td></tr></table></figure>
<h2 id="JZ54-二叉搜索树的第k个节点"><strong>JZ54</strong> 二叉搜索树的第k个节点</h2>
<p>给定一棵结点数为n 二叉搜索树，请找出其中的第 k 小的TreeNode结点值。</p>
<p>1.返回第k小的节点值即可</p>
<p>2.不能查找的情况，如二叉树为空，则返回-1，或者k大于n等等，也返回-1</p>
<p>3.保证n个节点的值不一样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">KthNode</span>(<span class="params">self , proot: TreeNode, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> k, res</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> k &lt; <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">            dfs(root.left)</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">0</span>: res = root.val</span><br><span class="line">            dfs(root.right)</span><br><span class="line">        res = -<span class="number">1</span></span><br><span class="line">        dfs(proot)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="JZ55-二叉树的深度"><strong>JZ55</strong> 二叉树的深度</h2>
<p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度，根节点的深度视为 1 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self , root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 空节点没有深度</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 返回子树深度+1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>([<span class="variable language_">self</span>.maxDepth(root.left), <span class="variable language_">self</span>.maxDepth(root.right)]) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">TreeDepth</span>(<span class="params">self , pRoot: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> res, dep</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                res = <span class="built_in">max</span>(res, dep)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dep += <span class="number">1</span></span><br><span class="line">            dfs(root.left)</span><br><span class="line">            dfs(root.right)</span><br><span class="line">            dep -= <span class="number">1</span></span><br><span class="line">        res = dep = <span class="number">0</span></span><br><span class="line">        dfs(pRoot)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="JZ56-数组中只出现一次的两个数字"><strong>JZ56</strong> 数组中只出现一次的两个数字</h2>
<p>一个整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">FindNumsAppearOnce</span>(<span class="params">self , nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        mp = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> mp: <span class="keyword">del</span> mp[num]</span><br><span class="line">            <span class="keyword">else</span>: mp[num] = <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> mp.keys():</span><br><span class="line">            res.append(num)</span><br><span class="line">        res.sort()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#异或运算</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">FindNumsAppearOnce</span>(<span class="params">self , nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums: tmp ^= num</span><br><span class="line">        k = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> k &amp; tmp == <span class="number">0</span>:</span><br><span class="line">            k &lt;&lt;= <span class="number">1</span></span><br><span class="line">        res = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> k &amp; num: res[<span class="number">0</span>] ^= num</span><br><span class="line">            <span class="keyword">else</span>: res[<span class="number">1</span>] ^= num</span><br><span class="line">        res.sort()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="JZ57-和为S的两个数字"><strong>JZ57</strong> 和为S的两个数字</h2>
<p>输入一个升序数组 array 和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，返回任意一组即可，如果无法找出这样的数字，返回一个空数组即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">FindNumbersWithSum</span>(<span class="params">self , array: <span class="type">List</span>[<span class="built_in">int</span>], <span class="built_in">sum</span>: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="built_in">len</span>(array)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> array[i] + array[j] &gt; <span class="built_in">sum</span>: j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> array[i] + array[j] &lt; <span class="built_in">sum</span>: i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">return</span> [array[i],array[j]]</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<h2 id="JZ58-左旋转字符串"><strong>JZ58</strong> 左旋转字符串</h2>
<p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列 S ，请你把其循环左移 K 位后的序列输出。例如，字符序列 S = ”abcXYZdef” , 要求输出循环左移 3 位后的结果，即 “XYZdefabc”</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">LeftRotateString</span>(<span class="params">self , <span class="built_in">str</span>: <span class="built_in">str</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">str</span>: <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        n = n % <span class="built_in">len</span>(<span class="built_in">str</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>[n:] + <span class="built_in">str</span>[:n]</span><br></pre></td></tr></table></figure>
<h2 id="JZ59-滑动窗口的最大值"><strong>JZ59</strong> 滑动窗口的最大值</h2>
<p>给定一个长度为 n 的数组 num 和滑动窗口的大小 size ，找出所有滑动窗口里数值的最大值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxInWindows</span>(<span class="params">self , num: <span class="type">List</span>[<span class="built_in">int</span>], size: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">        que = deque()</span><br><span class="line">        res = []</span><br><span class="line">        i = j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(num):</span><br><span class="line">            <span class="keyword">while</span> que <span class="keyword">and</span> que[-<span class="number">1</span>] &lt; num[j]: que.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> que <span class="keyword">or</span> que[-<span class="number">1</span>] &gt;= num[j]: que.append(num[j])</span><br><span class="line">            <span class="keyword">if</span> j &gt;= size-<span class="number">1</span>:</span><br><span class="line">                res.append(que[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">if</span> que[<span class="number">0</span>] == num[i]: que.popleft()</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="JZ61-扑克牌顺子"><strong>JZ61</strong> 扑克牌顺子</h2>
<p>现在有2副扑克牌，从扑克牌中随机五张扑克牌，我们需要来判断一下是不是顺子。<br>
有如下规则：<br>
\1. A为1，J为11，Q为12，K为13，A不能视为14<br>
\2. 大、小王为 0，0可以看作任意牌<br>
\3. 如果给出的五张牌能组成顺子（即这五张牌是连续的）就输出true，否则就输出false。<br>
4.数据保证每组5个数字，每组最多含有4个零，数组的数取值为 [0, 13]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">IsContinuous</span>(<span class="params">self , numbers: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        lst = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> num != <span class="number">0</span>: lst.append(num)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">set</span>(lst)) &lt; <span class="built_in">len</span>(lst): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">max</span>(lst) - <span class="built_in">min</span>(lst) &gt; <span class="number">4</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h2 id="JZ62-孩子们的游戏-圆圈中最后剩下的数"><strong>JZ62</strong> 孩子们的游戏(圆圈中最后剩下的数)</h2>
<p>每年六一儿童节，牛客都会准备一些小礼物和小游戏去看望孤儿院的孩子们。其中，有个游戏是这样的：首先，让 n 个小朋友们围成一个大圈，小朋友们的编号是0~n-1。然后，随机指定一个数 m ，让编号为0的小朋友开始报数。每次喊到 m-1 的那个小朋友要出列唱首歌，然后可以在礼品箱中任意的挑选礼物，并且不再回到圈中，从他的下一个小朋友开始，继续0… m-1报数…这样下去…直到剩下最后一个小朋友，可以不用表演，并且拿到牛客礼品，请你试着想下，哪个小朋友会得到这份礼品呢？</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211008/557336_1633683919444/969B0F1641FC5D27A2F517347991EB78" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">LastRemaining_Solution</span>(<span class="params">self , n: <span class="built_in">int</span>, m: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        x = <span class="number">0</span> <span class="comment">#约瑟夫环</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>): <span class="comment">#第i次代表第i个小朋友</span></span><br><span class="line">            x = (x + m) % i</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<h2 id="JZ64-求1-2-3-…-n"><strong>JZ64</strong> 求1+2+3+…+n</h2>
<p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Sum_Solution</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="keyword">return</span> n * (n+<span class="number">1</span>) // <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="JZ65-不用加减乘除做加法"><strong>JZ65</strong> 不用加减乘除做加法</h2>
<p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Add</span>(<span class="params">self , num1: <span class="built_in">int</span>, num2: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">while</span> num1: <span class="comment">#进位都为0时终止</span></span><br><span class="line">            <span class="comment">#将python中的数变为32位数</span></span><br><span class="line">            num1, num2 = ((num1 &amp; num2) &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0xffffffff</span> , (num1 ^ num2) &amp; <span class="number">0xffffffff</span>  <span class="comment">#分别为进位和原位</span></span><br><span class="line">        <span class="keyword">return</span> num2  <span class="keyword">if</span> num2 &lt;= <span class="number">0x7fffffff</span> <span class="keyword">else</span> ~(num2 ^ <span class="number">0xffffffff</span>) <span class="comment">#将32位数变为python中的数</span></span><br></pre></td></tr></table></figure>
<h2 id="JZ66-构建乘积数组"><strong>JZ66</strong> 构建乘积数组</h2>
<p>给定一个数组 A[0,1,…,n-1] ,请构建一个数组 B[0,1,…,n-1] ,其中 B 的元素 B[i]=A[0]<em>A[1]</em>…*A[i-1]<em>A[i+1]</em>…*A[n-1]（除 A[i] 以外的全部元素的的乘积）。程序中不能使用除法。（注意：规定 B[0] = A[1] * A[2] * … * A[n-1]，B[n-1] = A[0] * A[1] * … * A[n-2]）</p>
<p>对于 A 长度为 1 的情况，B 无意义，故而无法构建，用例中不包括这种情况。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#暴力</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">multiply</span>(<span class="params">self , A: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(A)</span><br><span class="line">        B = [<span class="number">1</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> j != i:</span><br><span class="line">                    B[i] *= A[j]</span><br><span class="line">        <span class="keyword">return</span> B</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#上下三角</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">multiply</span>(<span class="params">self , A: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(A)</span><br><span class="line">        B = [<span class="number">1</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            B[i] = B[i-<span class="number">1</span>] * A[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            B[i] *= A[i+<span class="number">1</span>]</span><br><span class="line">            A[i] *= A[i+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> B</span><br></pre></td></tr></table></figure>
<h2 id="JZ68-二叉搜索树的最近公共祖先"><strong>JZ68</strong> <strong>二叉搜索树的最近公共祖先</strong></h2>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>1.对于该题的最近的公共祖先定义:对于有根树T的两个节点p、q，最近公共祖先LCA(T,p,q)表示一个节点x，满足x是p和q的祖先且x的深度尽可能大。在这里，一个节点也可以是它自己的祖先.</p>
<p>2.二叉搜索树是若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值</p>
<p>3.所有节点的值都是唯一的。</p>
<p>4.p、q 为不同节点且均存在于给定的二叉搜索树中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self , root: TreeNode, p: <span class="built_in">int</span>, q: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> p &lt;= root.val &lt;= q <span class="keyword">or</span> q &lt;= root.val &lt;= p: <span class="keyword">return</span> root.val</span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="variable language_">self</span>.lowestCommonAncestor(root.left,p,q) <span class="keyword">or</span> \</span><br><span class="line">                     <span class="variable language_">self</span>.lowestCommonAncestor(root.right,p,q)</span><br></pre></td></tr></table></figure>
<h2 id="JZ69-跳台阶"><strong>JZ69</strong> 跳台阶</h2>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">jumpFloor</span>(<span class="params">self , number: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> number == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(number-<span class="number">1</span>):</span><br><span class="line">            a, b = b, a+b</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure>
<h2 id="JZ70-矩形覆盖"><strong>JZ70</strong> 矩形覆盖</h2>
<p>我们可以用 2<em>1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2</em>1 的小矩形无重叠地覆盖一个 2*n 的大矩形，从同一个方向看总共有多少种不同的方法？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rectCover</span>(<span class="params">self, number</span>):</span><br><span class="line">        <span class="keyword">if</span> number &lt;= <span class="number">1</span>: <span class="keyword">return</span> number</span><br><span class="line">        x, y = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(number-<span class="number">1</span>):</span><br><span class="line">            x, y = y, x+y</span><br><span class="line">        <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure>
<h2 id="JZ71-跳台阶扩展问题"><strong>JZ71</strong> 跳台阶扩展问题</h2>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶(n为正整数)总共有多少种跳法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">jumpFloorII</span>(<span class="params">self , number: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] * (number+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,number+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                dp[i] += dp[j]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="JZ73-翻转单词序列"><strong>JZ73</strong> 翻转单词序列</h2>
<p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“nowcoder. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a nowcoder.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python便捷写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ReverseSentence</span>(<span class="params">self , <span class="built_in">str</span>: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        lst = <span class="built_in">str</span>.split()[::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(lst)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#双指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ReverseSentence</span>(<span class="params">self , <span class="built_in">str</span>: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">str</span>: <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        n = <span class="built_in">len</span>(<span class="built_in">str</span>)</span><br><span class="line">        lst = []</span><br><span class="line">        i = j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">str</span>[i] == <span class="string">&#x27; &#x27;</span>: i += <span class="number">1</span></span><br><span class="line">            j = i</span><br><span class="line">            <span class="keyword">while</span> j &lt; n-<span class="number">1</span> <span class="keyword">and</span> <span class="built_in">str</span>[j+<span class="number">1</span>] != <span class="string">&#x27; &#x27;</span>:  j += <span class="number">1</span></span><br><span class="line">            lst.append(<span class="built_in">str</span>[i:j+<span class="number">1</span>])</span><br><span class="line">            i = j+<span class="number">1</span></span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lst)-<span class="number">1</span>):</span><br><span class="line">            res += lst.pop() + <span class="string">&#x27; &#x27;</span></span><br><span class="line">        <span class="keyword">return</span> res + lst.pop()</span><br></pre></td></tr></table></figure>
<h2 id="JZ74-和为S的连续正数序列"><strong>JZ74</strong> 和为S的连续正数序列</h2>
<p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#暴力</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">FindContinuousSequence</span>(<span class="params">self , <span class="built_in">sum</span>: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">sum</span>//<span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">            s = <span class="built_in">sum</span></span><br><span class="line">            lst = []</span><br><span class="line">            <span class="keyword">while</span> s &gt; <span class="number">0</span>:</span><br><span class="line">                lst.append(i)</span><br><span class="line">                s -= i</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s == <span class="number">0</span>: res.append(lst)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#滑动窗口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">FindContinuousSequence</span>(<span class="params">self , <span class="built_in">sum</span>: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        i, j = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">        r = <span class="built_in">sum</span>//<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= r <span class="keyword">and</span> j &lt;= r:</span><br><span class="line">            s = (i+j)*(j+<span class="number">1</span>-i)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> s == <span class="built_in">sum</span>:</span><br><span class="line">                res.append([_ <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(i,j+<span class="number">1</span>)])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> j &lt;= r-<span class="number">1</span> <span class="keyword">and</span>  s &lt; <span class="built_in">sum</span>: j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="JZ75-字符流中第一个不重复的字符"><strong>JZ75</strong> 字符流中第一个不重复的字符</h2>
<p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 “go” 时，第一个只出现一次的字符是 “g” 。当从该字符流中读出前六个字符 “google&quot; 时，第一个只出现一次的字符是&quot;l&quot;。</p>
<p>数据范围：字符串长度满足 1≤�≤1000 1≤<em>n</em>≤1000 ，字符串中出现的字符一定在 ASCII 码内。<br>
进阶：空间复杂度 �(�) <em>O</em>(<em>n</em>) ，时间复杂度 �(�) <em>O</em>(<em>n</em>)</p>
<p>后台会用以下方式调用 Insert 和 FirstAppearingOnce 函数</p>
<blockquote>
<p>string caseout = “”;</p>
<p>1.读入测试用例字符串casein</p>
<p>2.如果对应语言有Init()函数的话，执行Init() 函数</p>
<p>3.循环遍历字符串里的每一个字符ch {</p>
<p>Insert(ch);</p>
<p>caseout += FirstAppearingOnce()</p>
<p>}</p>
<p>\2. 输出caseout，进行比较。</p>
</blockquote>
<p>如果当前字符流没有存在出现一次的字符，返回#字符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.char = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="variable language_">self</span>.cnt = &#123;&#125;</span><br><span class="line">        <span class="variable language_">self</span>.n = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">FirstAppearingOnce</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="variable language_">self</span>.n &lt; <span class="built_in">len</span>(<span class="variable language_">self</span>.char) <span class="keyword">and</span> <span class="variable language_">self</span>.cnt[<span class="variable language_">self</span>.char[<span class="variable language_">self</span>.n]] &gt; <span class="number">1</span>: <span class="variable language_">self</span>.n += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.char[<span class="variable language_">self</span>.n] <span class="keyword">if</span> <span class="variable language_">self</span>.n &lt; <span class="built_in">len</span>(<span class="variable language_">self</span>.char) <span class="keyword">else</span> <span class="string">&#x27;#&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Insert</span>(<span class="params">self, char</span>):</span><br><span class="line">        <span class="keyword">if</span> char <span class="keyword">in</span> <span class="variable language_">self</span>.cnt:</span><br><span class="line">            <span class="variable language_">self</span>.cnt[char] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="variable language_">self</span>.cnt[char] = <span class="number">1</span></span><br><span class="line">            <span class="variable language_">self</span>.char += char</span><br></pre></td></tr></table></figure>
<h2 id="JZ76-删除链表中重复的结点"><strong>JZ76</strong> 删除链表中重复的结点</h2>
<p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#直接删除，无序列表可以考虑哈希表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplication</span>(<span class="params">self , pHead: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead: <span class="keyword">return</span></span><br><span class="line">        head = ListNode(<span class="number">0</span>)</span><br><span class="line">        head.<span class="built_in">next</span> = pHead</span><br><span class="line">        tail = head</span><br><span class="line">        <span class="keyword">while</span> tail.<span class="built_in">next</span> <span class="keyword">and</span> tail.<span class="built_in">next</span>.<span class="built_in">next</span>:  </span><br><span class="line">            <span class="keyword">if</span> tail.<span class="built_in">next</span>.val == tail.<span class="built_in">next</span>.<span class="built_in">next</span>.val:</span><br><span class="line">                val = tail.<span class="built_in">next</span>.val</span><br><span class="line">                <span class="comment">#跳过所有重复值</span></span><br><span class="line">                <span class="keyword">while</span> tail.<span class="built_in">next</span> <span class="keyword">and</span> tail.<span class="built_in">next</span>.val == val:</span><br><span class="line">                    tail.<span class="built_in">next</span> = tail.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>: tail = tail.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<h2 id="JZ78-把二叉树打印成多行"><strong>JZ78</strong> 把二叉树打印成多行</h2>
<p>给定一个节点数为 n 二叉树，要求从上到下按层打印二叉树的 val 值，同一层结点从左至右输出，每一层输出一行，将输出的结果存放到一个二维数组中返回。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#层级遍历</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Print</span>(<span class="params">self , pRoot: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot: <span class="keyword">return</span> []</span><br><span class="line">        qe = deque([pRoot])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> qe:</span><br><span class="line">            lst = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(qe)):</span><br><span class="line">                node = qe.popleft()</span><br><span class="line">                lst.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: qe.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: qe.append(node.right)</span><br><span class="line">            res.append(lst)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="JZ79-判断是不是平衡二叉树"><strong>JZ79</strong> 判断是不是平衡二叉树</h2>
<p>输入一棵节点数为 n 二叉树，判断该二叉树是否是平衡二叉树。</p>
<p>在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树</p>
<p><strong>平衡二叉树</strong>（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#自上而下</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">height</span>(<span class="params">self,pRoot</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="variable language_">self</span>.height(pRoot.left), <span class="variable language_">self</span>.height(pRoot.right)) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">IsBalanced_Solution</span>(<span class="params">self , pRoot: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.IsBalanced_Solution(pRoot.left) <span class="keyword">and</span> <span class="variable language_">self</span>.IsBalanced_Solution(pRoot.right) <span class="keyword">and</span>\</span><br><span class="line">               <span class="built_in">abs</span>(<span class="variable language_">self</span>.height(pRoot.left) - <span class="variable language_">self</span>.height(pRoot.right)) &lt;= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#自下而上</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">IsBalanced_Solution</span>(<span class="params">self , pRoot: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">height</span>(<span class="params">pRoot</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pRoot: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            left = height(pRoot.left)</span><br><span class="line">            <span class="keyword">if</span> left &lt; <span class="number">0</span>: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            right = height(pRoot.right)</span><br><span class="line">            <span class="keyword">if</span> right &lt; <span class="number">0</span>: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> <span class="built_in">abs</span>(left-right)&gt;<span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span> + <span class="built_in">max</span>(left,right)</span><br><span class="line">        <span class="keyword">return</span> height(pRoot) != -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="JZ81-调整数组顺序使奇数位于偶数前面-二"><strong>JZ81</strong> 调整数组顺序使奇数位于偶数前面(二)</h2>
<p>输入一个长度为 n 整数数组，数组里面可能含有相同的元素，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前面部分，所有的偶数位于数组的后面部分，对奇数和奇数，偶数和偶数之间的相对位置不做要求，但是时间复杂度和空间复杂度必须如下要求。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reOrderArrayTwo</span>(<span class="params">self , array: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="built_in">len</span>(array)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> array[i] % <span class="number">2</span> == <span class="number">1</span>: i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> array[j] % <span class="number">2</span> == <span class="number">0</span>: j -= <span class="number">1</span></span><br><span class="line">            array[i], array[j] = array[j], array[i]</span><br><span class="line">        <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure>
<h2 id="JZ83-剪绳子（进阶版）"><strong>JZ83</strong> 剪绳子（进阶版）</h2>
<p>给你一根长度为 n 的绳子，请把绳子剪成整数长的 m 段（ m 、 n 都是整数， n &gt; 1 并且 m &gt; 1 ， m &lt;= n ），每段绳子的长度记为 k[1],…,k[m] 。请问 k[1]<em>k[2]</em>…*k[m] 可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18 。</p>
<p>由于答案过大，请对 998244353 取模。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#快速幂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cutRope</span>(<span class="params">self , number: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> number &lt;= <span class="number">3</span>: <span class="keyword">return</span> number - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">quickpow</span>(<span class="params">a, b</span>):</span><br><span class="line">            res = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> b:</span><br><span class="line">                <span class="keyword">if</span> b % <span class="number">2</span>: res = res * a % <span class="number">998244353</span></span><br><span class="line">                b &gt;&gt;= <span class="number">1</span></span><br><span class="line">                a = a*a % <span class="number">998244353</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        x, y = number // <span class="number">3</span>, number % <span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> y == <span class="number">0</span>: <span class="keyword">return</span> quickpow(<span class="number">3</span>,x)</span><br><span class="line">        <span class="keyword">elif</span> y == <span class="number">1</span>: <span class="keyword">return</span> quickpow(<span class="number">3</span>,x-<span class="number">1</span>) * <span class="number">4</span> % <span class="number">998244353</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> quickpow(<span class="number">3</span>,x) * <span class="number">2</span> % <span class="number">998244353</span></span><br></pre></td></tr></table></figure>
<h2 id="JZ84-二叉树中和为某一值的路径-三"><strong>JZ84</strong> 二叉树中和为某一值的路径(三)</h2>
<p>给定一个二叉树root和一个整数值 sum ，求该树有多少路径的的节点值之和等于 sum 。</p>
<p>1.该题路径定义不需要从根节点开始，也不需要在叶子节点结束，但是一定是从父亲节点往下到孩子节点</p>
<p>2.总节点数目为n</p>
<p>3.保证最后返回的路径个数在整形范围内(即路径个数小于231-1)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#两次遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.path = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">FindPath</span>(<span class="params">self , root: TreeNode, <span class="built_in">sum</span>: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">treesum</span>(<span class="params">root,<span class="built_in">sum</span></span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            <span class="built_in">sum</span> -= root.val</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> == <span class="number">0</span>: <span class="variable language_">self</span>.path += <span class="number">1</span></span><br><span class="line">            treesum(root.left,<span class="built_in">sum</span>)</span><br><span class="line">            treesum(root.right,<span class="built_in">sum</span>)</span><br><span class="line">            <span class="built_in">sum</span> += root.val</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root,<span class="built_in">sum</span></span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            treesum(root,<span class="built_in">sum</span>)</span><br><span class="line">            dfs(root.left,<span class="built_in">sum</span>)</span><br><span class="line">            dfs(root.right,<span class="built_in">sum</span>)</span><br><span class="line"></span><br><span class="line">        dfs(root,<span class="built_in">sum</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.path</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一次遍历+哈希表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment">#记录路径和及条数</span></span><br><span class="line">        <span class="variable language_">self</span>.mp = <span class="built_in">dict</span>()</span><br><span class="line">        </span><br><span class="line">    <span class="comment">#last为到上一层为止的累加和</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self, root: TreeNode, <span class="built_in">sum</span>: <span class="built_in">int</span>, last: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">#空结点直接返回</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="comment">#到目前结点为止的累加和</span></span><br><span class="line">        temp = root.val + last; </span><br><span class="line">        <span class="comment">#如果该累加和减去sum在哈希表中出现过，相当于减去前面的分支</span></span><br><span class="line">        <span class="keyword">if</span> (temp - <span class="built_in">sum</span>) <span class="keyword">in</span> <span class="variable language_">self</span>.mp:</span><br><span class="line">            <span class="comment">#加上有的路径数</span></span><br><span class="line">            res += <span class="variable language_">self</span>.mp[temp - <span class="built_in">sum</span>] </span><br><span class="line">        <span class="comment">#增加该次路径和</span></span><br><span class="line">        <span class="keyword">if</span> temp <span class="keyword">in</span> <span class="variable language_">self</span>.mp:</span><br><span class="line">            <span class="variable language_">self</span>.mp[temp] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.mp[temp] = <span class="number">1</span> </span><br><span class="line">        <span class="comment">#进入子结点</span></span><br><span class="line">        res += <span class="variable language_">self</span>.dfs(root.left, <span class="built_in">sum</span>, temp) </span><br><span class="line">        res += <span class="variable language_">self</span>.dfs(root.right, <span class="built_in">sum</span>, temp) </span><br><span class="line">        <span class="comment">#回退该路径和，因为别的树枝不需要这边存的路径和</span></span><br><span class="line">        <span class="variable language_">self</span>.mp[temp] -= <span class="number">1</span> </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">FindPath</span>(<span class="params">self , root: TreeNode, <span class="built_in">sum</span>: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">#路径和为0的有1条</span></span><br><span class="line">        <span class="variable language_">self</span>.mp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.dfs(root, <span class="built_in">sum</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h2 id="JZ85-连续子数组的最大和-二"><strong>JZ85</strong> 连续子数组的最大和(二)</h2>
<p>输入一个长度为n的整型数组array，数组中的一个或连续多个整数组成一个子数组，找到一个具有最大和的连续子数组。</p>
<p>1.子数组是连续的，比如[1,3,5,7,9]的子数组有[1,3]，[3,5,7]等等，但是[1,3,7]不是子数组</p>
<p>2.如果存在多个最大和的连续子数组，那么返回其中长度最长的，该题数据保证这个最长的只存在一个</p>
<p>3.该题定义的子数组的最小长度为1，不存在为空的子数组，即不存在[]是某个数组的子数组</p>
<p>4.返回的数组不计入空间复杂度计算</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">FindGreatestSumOfSubArray</span>(<span class="params">self , array: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        dp = [[array[<span class="number">0</span>]], array[<span class="number">0</span>], <span class="number">1</span>]</span><br><span class="line">        res = [[array[<span class="number">0</span>]], array[<span class="number">0</span>], <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> dp[<span class="number">1</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">                dp[<span class="number">0</span>] += [array[i]]</span><br><span class="line">                dp[<span class="number">1</span>] += array[i]</span><br><span class="line">                dp[<span class="number">2</span>] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                dp[<span class="number">0</span>] = [array[i]]</span><br><span class="line">                dp[<span class="number">1</span>] = array[i]</span><br><span class="line">                dp[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> res[<span class="number">1</span>] &lt; dp[<span class="number">1</span>] <span class="keyword">or</span> (res[<span class="number">1</span>] == dp[<span class="number">1</span>] <span class="keyword">and</span> res[<span class="number">2</span>] &lt; dp[<span class="number">2</span>]):</span><br><span class="line">                res = [dp[<span class="number">0</span>].copy(),dp[<span class="number">1</span>],dp[<span class="number">2</span>]]</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#动态规划+滑动窗口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">FindGreatestSumOfSubArray</span>(<span class="params">self , array: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        dp = array[<span class="number">0</span>]</span><br><span class="line">        l = <span class="number">0</span> <span class="comment">#滑动窗口左端</span></span><br><span class="line">        maxsum = array[<span class="number">0</span>] <span class="comment">#最大子数组和</span></span><br><span class="line">        resl, resr = <span class="number">0</span>, <span class="number">0</span> <span class="comment">#最大子数组左右端</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(array)): <span class="comment">#r为滑动窗口右端</span></span><br><span class="line">            <span class="keyword">if</span> dp &gt;= <span class="number">0</span>: dp += array[r]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp = array[r]</span><br><span class="line">                l = r</span><br><span class="line">            <span class="keyword">if</span> dp &gt; maxsum <span class="keyword">or</span> (dp == maxsum <span class="keyword">and</span> r-l &gt; resr-resl):</span><br><span class="line">                maxsum = dp</span><br><span class="line">                resl, resr = l, r</span><br><span class="line">        <span class="keyword">return</span> array[resl:resr+<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="JZ86-在二叉树中找到两个节点的最近公共祖先"><strong>JZ86</strong> 在二叉树中找到两个节点的最近公共祖先</h2>
<p>给定一棵二叉树(保证非空)以及这棵树上的两个节点对应的val值 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#找到各自的路径，找到最近公共祖先</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self , root: TreeNode, o1: <span class="built_in">int</span>, o2: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        path = []</span><br><span class="line">        lst1, lst2 = [], []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root,o1,o2</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            path.append(root.val)</span><br><span class="line">            <span class="keyword">if</span> root.val == o1:</span><br><span class="line">                <span class="keyword">for</span> item <span class="keyword">in</span> path: lst1.append(item)</span><br><span class="line">            <span class="keyword">if</span> root.val == o2: </span><br><span class="line">                <span class="keyword">for</span> item <span class="keyword">in</span> path: lst2.append(item)</span><br><span class="line">            dfs(root.left,o1,o2)</span><br><span class="line">            dfs(root.right,o1,o2)</span><br><span class="line">            path.pop()</span><br><span class="line">        dfs(root,o1,o2)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">min</span>(<span class="built_in">len</span>(lst1),<span class="built_in">len</span>(lst2))):</span><br><span class="line">            <span class="keyword">if</span> lst1[i] == lst2[i]: res.append(lst1[i])</span><br><span class="line">        <span class="keyword">return</span> res[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#递归思想</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self , root: TreeNode, o1: <span class="built_in">int</span>, o2: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> root.val == o1 <span class="keyword">or</span> root.val == o2: <span class="keyword">return</span> root.val</span><br><span class="line">        left = <span class="variable language_">self</span>.lowestCommonAncestor(root.left,o1,o2)</span><br><span class="line">        right = <span class="variable language_">self</span>.lowestCommonAncestor(root.right,o1,o2)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right: <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left: <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> right: <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">return</span> root.val</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://anym0re.cn">anym0re</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://anym0re.cn/2024/03/28/offer/">http://anym0re.cn/2024/03/28/offer/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://anym0re.cn" target="_blank">陪小付度过漫长岁月</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BB%A3%E7%A0%81/">代码</a><a class="post-meta__tags" href="/tags/python/">python</a><a class="post-meta__tags" href="/tags/%E7%89%9B%E5%AE%A2/">牛客</a></div><div class="post-share"><div class="social-share" data-image="https://s2.loli.net/2024/02/25/zIWeRaZnF8Vxsqv.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/03/31/%E7%AC%94%E8%AF%95/" title="实习生笔试"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">实习生笔试</div></div><div class="info-2"><div class="info-item-1">3.30腾讯笔试 1.西洋棋皇后能走的格数（20分） 一般来说任何考试第一题都很简单，所以一开始思想上轻敌了，再加上第一次笔试十分紧张，所以在第一题上浪费了大量时间。 捋顺思路遍历即可 2.通过几次操作可以让数组内的奇偶数相同（20分） 最先做出来的是第二题，算是帮我稳住了军心，否则估计零蛋了 先遍历数奇偶，奇数多直接输出gap//2，偶数多优先操作变奇最快的偶数（质因子含2最少） 3.统计成绩异常（20分） 题目太长没看 4.n个城市，m条双向路线，1到n的最小时间（20分） 应该是用Dijkstra，题目太长没看 5.无限循环小数的循环节（20分） 第一题耗费了太久时间，只能从后三道题中选一道做，因为这道题题目最短最容易读懂，就选了这道题，事实证明大错特错 思路应该是需要数学方法来证明，和编程关系不大 3.31美的笔试 选择题（40分） 机器学习和深度学习相关，基本全靠蒙 编程题（60分） 数组排序 送分题 有效括号 原题 栈+哈希表 最长任意两个元素按位与为0的子数组 基本也不太用想 dp，dp[i]表示以nums[i]结尾符合条件的最长子数组 3.31微众银行 选择题（4...</div></div></div></a><a class="pagination-related" href="/2024/03/19/d2l/" title="在李沐大神d2l中踩过的坑"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">在李沐大神d2l中踩过的坑</div></div><div class="info-2"><div class="info-item-1">最近在用pytorch框架学习李沐大神的d2l，因为时间过去已久，可能因为版本等原因出现了一些问题，有些问题在网上找不到解决办法，在这里记录一下遇到的坑。 图片不显示文字 问题  坐标轴和图例都不显示文字，排查之后发现是svg格式渲染导致的问题，换一个格式就可以正常显示了。  解决方法 将torch源文件中的use_svg_display()函数中的backend_inline.set_matplotlib_formats(‘svg’)改为backend_inline.set_matplotlib_formats(‘png’)可以暂时缓解问题。  源文件路径在 环境/lib/site-packages/d2l/torch.py  </div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/04/11/%E9%9D%A2%E8%AF%95/" title="面试"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-11</div><div class="info-item-2">面试</div></div><div class="info-2"><div class="info-item-1">4.11联想一面 天津，官网投递，线上面 1.自我介绍（中文） 2.为什么当时去工作了？ 认识了初创团队的人，一块创业 3.实习经历 之前同事引荐，做产品 4.聊一个你最熟悉的算法，有什么实际应用吗？ 动态规划，主要是做题，实际中没用过 5.你在做模型的时候遇到什么困难，怎么解决的？ 坐标轴不显示，改源文件 6.反问：流程 可能会有业务面，不管是否通过都会有结果 7.反问：天津这边有什么业务 按业务来分，不是按地方分 感觉是kpi面，十多分钟就结束了 4.17 上海乌托邦二面 上海，BOSS投递，线上面 说是二面，其实一面就是给了我七个智力题，做完第二天约了二面。 两个面试官，问了下我的经历，然后问了我大模型了解哪些。我基本不知道，就问我推荐相关的东西，答了些基本的，面了十分钟就结束了，让等通知。 应该是G了。 4.18 天津英福 校友企业，学校老师介绍的，线下面。 主要是聊天，聊了30分钟。基本没有问我什么专业问题，主要是介绍情况，说可以提供服务器和卡让我们研究，后期几个实习生一块做项目。 校友人很好，只要是南开的学生就欢迎。 4.18 天津亿数 天津，BOSS投递，线下面 两...</div></div></div></a><a class="pagination-related" href="/2024/04/05/hot100/" title="leetcode-hot100"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-05</div><div class="info-item-2">leetcode-hot100</div></div><div class="info-2"><div class="info-item-1">哈希 1. 两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 1234567#穷举class Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        n = len(nums)        for i in range(n):            for j in range(i+1,n):                if nums[i] + nums[j] == target: return [i,j] 1234567#哈希表class Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        mp = &#123;&#125;     ...</div></div></div></a><a class="pagination-related" href="/2024/03/31/%E7%AC%94%E8%AF%95/" title="实习生笔试"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-31</div><div class="info-item-2">实习生笔试</div></div><div class="info-2"><div class="info-item-1">3.30腾讯笔试 1.西洋棋皇后能走的格数（20分） 一般来说任何考试第一题都很简单，所以一开始思想上轻敌了，再加上第一次笔试十分紧张，所以在第一题上浪费了大量时间。 捋顺思路遍历即可 2.通过几次操作可以让数组内的奇偶数相同（20分） 最先做出来的是第二题，算是帮我稳住了军心，否则估计零蛋了 先遍历数奇偶，奇数多直接输出gap//2，偶数多优先操作变奇最快的偶数（质因子含2最少） 3.统计成绩异常（20分） 题目太长没看 4.n个城市，m条双向路线，1到n的最小时间（20分） 应该是用Dijkstra，题目太长没看 5.无限循环小数的循环节（20分） 第一题耗费了太久时间，只能从后三道题中选一道做，因为这道题题目最短最容易读懂，就选了这道题，事实证明大错特错 思路应该是需要数学方法来证明，和编程关系不大 3.31美的笔试 选择题（40分） 机器学习和深度学习相关，基本全靠蒙 编程题（60分） 数组排序 送分题 有效括号 原题 栈+哈希表 最长任意两个元素按位与为0的子数组 基本也不太用想 dp，dp[i]表示以nums[i]结尾符合条件的最长子数组 3.31微众银行 选择题（4...</div></div></div></a><a class="pagination-related" href="/2024/03/19/d2l/" title="在李沐大神d2l中踩过的坑"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-19</div><div class="info-item-2">在李沐大神d2l中踩过的坑</div></div><div class="info-2"><div class="info-item-1">最近在用pytorch框架学习李沐大神的d2l，因为时间过去已久，可能因为版本等原因出现了一些问题，有些问题在网上找不到解决办法，在这里记录一下遇到的坑。 图片不显示文字 问题  坐标轴和图例都不显示文字，排查之后发现是svg格式渲染导致的问题，换一个格式就可以正常显示了。  解决方法 将torch源文件中的use_svg_display()函数中的backend_inline.set_matplotlib_formats(‘svg’)改为backend_inline.set_matplotlib_formats(‘png’)可以暂时缓解问题。  源文件路径在 环境/lib/site-packages/d2l/torch.py  </div></div></div></a><a class="pagination-related" href="/2024/03/10/leetcode-%E5%91%A8%E8%B5%9B/" title="leetcode周赛"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-10</div><div class="info-item-2">leetcode周赛</div></div><div class="info-2"><div class="info-item-1">第388场周赛（模拟参赛） 100233. 重新分装苹果 给你一个长度为 n 的数组 apple 和另一个长度为 m 的数组 capacity 。 一共有 n 个包裹，其中第 i 个包裹中装着 apple[i] 个苹果。同时，还有 m 个箱子，第 i 个箱子的容量为 capacity[i] 个苹果。 请你选择一些箱子来将这 n 个包裹中的苹果重新分装到箱子中，返回你需要选择的箱子的 最小 数量。 注意，同一个包裹中的苹果可以分装到不同的箱子中 12345678class Solution:    def minimumBoxes(self, apple: List[int], capacity: List[int]) -&gt; int:        capacity.sort(reverse=True)        s = sum(apple)        for i,item in enumerate(capacity):            s -= item            if s &lt;= 0:                return i+1 10...</div></div></div></a><a class="pagination-related" href="/2024/03/03/leetcode-everyday/" title="leetcode每日一题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-03</div><div class="info-item-2">leetcode每日一题</div></div><div class="info-2"><div class="info-item-1">2024年 3月 1号_2369. 检查数组是否存在有效划分 给你一个下标从 0 开始的整数数组 nums ，你必须将数组划分为一个或多个 连续 子数组。 如果获得的这些子数组中每个都能满足下述条件 之一 ，则可以称其为数组的一种 有效 划分：  子数组 恰 由 2 个相等元素组成，例如，子数组 [2,2] 。 子数组 恰 由 3 个相等元素组成，例如，子数组 [4,4,4] 。 子数组 恰 由 3 个连续递增元素组成，并且相邻元素之间的差值为 1 。例如，子数组 [3,4,5] ，但是子数组 [1,3,5] 不符合要求。  如果数组 至少 存在一种有效划分，返回 true ，否则，返回 false 。 1234567891011class Solution:    def validPartition(self, nums: List[int]) -&gt; bool:        #动态规划,注意子数组为连续子数组，所以有效划分必须连在一起        n = len(nums)        f = [True] + [False] * n   #f(i+1)表示能有效...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://s2.loli.net/2024/02/25/zIWeRaZnF8Vxsqv.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">anym0re</div><div class="author-info-description">送给小付的情书</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/linmu130"><i class="fab fa-github"></i><span>关注我的Github</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/linmu130" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:13020037606@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客，这里用作anym0re记录自己的工作和生活，可以在左下角切歌或关闭音乐，欢迎留言评论。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ3-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">1.</span> <span class="toc-text">JZ3 数组中重复的数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ5-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="toc-number">2.</span> <span class="toc-text">JZ5 替换空格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ6-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">JZ6 从尾到头打印链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ7-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.</span> <span class="toc-text">JZ7 重建二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ8-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-number">5.</span> <span class="toc-text">JZ8 二叉树的下一个结点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ9-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">6.</span> <span class="toc-text">JZ9 用两个栈实现队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ10-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-number">7.</span> <span class="toc-text">JZ10 斐波那契数列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ11-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97"><span class="toc-number">8.</span> <span class="toc-text">JZ11 旋转数组的最小数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ12-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">9.</span> <span class="toc-text">JZ12 矩阵中的路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ13-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">10.</span> <span class="toc-text">JZ13 机器人的运动范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ14-%E5%89%AA%E7%BB%B3%E5%AD%90"><span class="toc-number">11.</span> <span class="toc-text">JZ14 剪绳子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ15-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">12.</span> <span class="toc-text">JZ15 二进制中1的个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ16-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9"><span class="toc-number">13.</span> <span class="toc-text">JZ16 数值的整数次方</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ17-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0"><span class="toc-number">14.</span> <span class="toc-text">JZ17 打印从1到最大的n位数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">15.</span> <span class="toc-text">JZ18 删除链表的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ20-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">16.</span> <span class="toc-text">JZ20 表示数值的字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ21-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2-%E4%B8%80"><span class="toc-number">17.</span> <span class="toc-text">JZ21 调整数组顺序使奇数位于偶数前面(一)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E6%9C%80%E5%90%8Ek%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-number">18.</span> <span class="toc-text">JZ22 链表中倒数最后k个结点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ23-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9"><span class="toc-number">19.</span> <span class="toc-text">JZ23 链表中环的入口结点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">20.</span> <span class="toc-text">JZ24 反转链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ25-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="toc-number">21.</span> <span class="toc-text">JZ25 合并两个排序的链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ26-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="toc-number">22.</span> <span class="toc-text">JZ26 树的子结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ27-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F"><span class="toc-number">23.</span> <span class="toc-text">JZ27 二叉树的镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ29-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5"><span class="toc-number">24.</span> <span class="toc-text">JZ29 顺时针打印矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ30-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88"><span class="toc-number">25.</span> <span class="toc-text">JZ30 包含min函数的栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ31-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97"><span class="toc-number">26.</span> <span class="toc-text">JZ31 栈的压入、弹出序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ32-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">27.</span> <span class="toc-text">JZ32 从上往下打印二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ33-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97"><span class="toc-number">28.</span> <span class="toc-text">JZ33 二叉搜索树的后序遍历序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-number">29.</span> <span class="toc-text">JZ35 复杂链表的复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ36-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">30.</span> <span class="toc-text">JZ36 二叉搜索树与双向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ37-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">31.</span> <span class="toc-text">JZ37 序列化二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ38-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="toc-number">32.</span> <span class="toc-text">JZ38 字符串的排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">33.</span> <span class="toc-text">JZ39 数组中出现次数超过一半的数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ40-%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0"><span class="toc-number">34.</span> <span class="toc-text">JZ40 最小的K个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ41-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-number">35.</span> <span class="toc-text">JZ41 数据流中的中位数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ43-%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%EF%BC%88%E4%BB%8E1%E5%88%B0n%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%EF%BC%89"><span class="toc-number">36.</span> <span class="toc-text">JZ43 整数中1出现的次数（从1到n整数中1出现的次数）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ44-%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">37.</span> <span class="toc-text">JZ44 数字序列中某一位的数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ45-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0"><span class="toc-number">38.</span> <span class="toc-text">JZ45 把数组排成最小的数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ46-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">39.</span> <span class="toc-text">JZ46 把数字翻译成字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ47-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC"><span class="toc-number">40.</span> <span class="toc-text">JZ47 礼物的最大价值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ48-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">41.</span> <span class="toc-text">JZ48 最长不含重复字符的子字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ49-%E4%B8%91%E6%95%B0"><span class="toc-number">42.</span> <span class="toc-text">JZ49 丑数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ51-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="toc-number">43.</span> <span class="toc-text">JZ51 数组中的逆序对</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9"><span class="toc-number">44.</span> <span class="toc-text">JZ52 两个链表的第一个公共结点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">45.</span> <span class="toc-text">JZ54 二叉搜索树的第k个节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ55-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="toc-number">46.</span> <span class="toc-text">JZ55 二叉树的深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ56-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="toc-number">47.</span> <span class="toc-text">JZ56 数组中只出现一次的两个数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ57-%E5%92%8C%E4%B8%BAS%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="toc-number">48.</span> <span class="toc-text">JZ57 和为S的两个数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ58-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">49.</span> <span class="toc-text">JZ58 左旋转字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ59-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">50.</span> <span class="toc-text">JZ59 滑动窗口的最大值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ61-%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90"><span class="toc-number">51.</span> <span class="toc-text">JZ61 扑克牌顺子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ62-%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0"><span class="toc-number">52.</span> <span class="toc-text">JZ62 孩子们的游戏(圆圈中最后剩下的数)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ64-%E6%B1%821-2-3-%E2%80%A6-n"><span class="toc-number">53.</span> <span class="toc-text">JZ64 求1+2+3+…+n</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ65-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95"><span class="toc-number">54.</span> <span class="toc-text">JZ65 不用加减乘除做加法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ66-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84"><span class="toc-number">55.</span> <span class="toc-text">JZ66 构建乘积数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ68-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">56.</span> <span class="toc-text">JZ68 二叉搜索树的最近公共祖先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ69-%E8%B7%B3%E5%8F%B0%E9%98%B6"><span class="toc-number">57.</span> <span class="toc-text">JZ69 跳台阶</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ70-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96"><span class="toc-number">58.</span> <span class="toc-text">JZ70 矩形覆盖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ71-%E8%B7%B3%E5%8F%B0%E9%98%B6%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98"><span class="toc-number">59.</span> <span class="toc-text">JZ71 跳台阶扩展问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ73-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%BA%8F%E5%88%97"><span class="toc-number">60.</span> <span class="toc-text">JZ73 翻转单词序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ74-%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97"><span class="toc-number">61.</span> <span class="toc-text">JZ74 和为S的连续正数序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ75-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-number">62.</span> <span class="toc-text">JZ75 字符流中第一个不重复的字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ76-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9"><span class="toc-number">63.</span> <span class="toc-text">JZ76 删除链表中重复的结点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ78-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C"><span class="toc-number">64.</span> <span class="toc-text">JZ78 把二叉树打印成多行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ79-%E5%88%A4%E6%96%AD%E6%98%AF%E4%B8%8D%E6%98%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">65.</span> <span class="toc-text">JZ79 判断是不是平衡二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ81-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2-%E4%BA%8C"><span class="toc-number">66.</span> <span class="toc-text">JZ81 调整数组顺序使奇数位于偶数前面(二)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ83-%E5%89%AA%E7%BB%B3%E5%AD%90%EF%BC%88%E8%BF%9B%E9%98%B6%E7%89%88%EF%BC%89"><span class="toc-number">67.</span> <span class="toc-text">JZ83 剪绳子（进阶版）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ84-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84-%E4%B8%89"><span class="toc-number">68.</span> <span class="toc-text">JZ84 二叉树中和为某一值的路径(三)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ85-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C-%E4%BA%8C"><span class="toc-number">69.</span> <span class="toc-text">JZ85 连续子数组的最大和(二)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ86-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">70.</span> <span class="toc-text">JZ86 在二叉树中找到两个节点的最近公共祖先</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/11/%E9%9D%A2%E8%AF%95/" title="面试">面试</a><time datetime="2024-04-11T07:20:34.000Z" title="发表于 2024-04-11 15:20:34">2024-04-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/05/hot100/" title="leetcode-hot100">leetcode-hot100</a><time datetime="2024-04-05T04:25:58.000Z" title="发表于 2024-04-05 12:25:58">2024-04-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/31/%E7%AC%94%E8%AF%95/" title="实习生笔试">实习生笔试</a><time datetime="2024-03-31T04:56:31.000Z" title="发表于 2024-03-31 12:56:31">2024-03-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/28/offer/" title="剑指offer">剑指offer</a><time datetime="2024-03-28T02:44:52.000Z" title="发表于 2024-03-28 10:44:52">2024-03-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/19/d2l/" title="在李沐大神d2l中踩过的坑">在李沐大神d2l中踩过的坑</a><time datetime="2024-03-19T08:56:17.000Z" title="发表于 2024-03-19 16:56:17">2024-03-19</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2024 - 2025 By anym0re</span></div><div class="footer_custom_text">陪伴是最长情的告白</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.4.3"></script><script src="/js/main.js?v=5.4.3"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://linmu130-anym0re.hf.space',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://linmu130-anym0re.hf.space',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.44/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script src="/js/sakura.js"></script><div class="aplayer no-destroy" data-id="614635824" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/fireworks.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>