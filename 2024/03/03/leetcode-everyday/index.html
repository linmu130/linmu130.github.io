<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>leetcode每日一题 | 陪小付度过漫长岁月</title><meta name="author" content="anym0re"><meta name="copyright" content="anym0re"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="2024年 3月 1号_2369. 检查数组是否存在有效划分 给你一个下标从 0 开始的整数数组 nums ，你必须将数组划分为一个或多个 连续 子数组。 如果获得的这些子数组中每个都能满足下述条件 之一 ，则可以称其为数组的一种 有效 划分：  子数组 恰 由 2 个相等元素组成，例如，子数组 [2,2] 。 子数组 恰 由 3 个相等元素组成，例如，子数组 [4,4,4] 。 子数组 恰 由">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode每日一题">
<meta property="og:url" content="http://anym0re.cn/2024/03/03/leetcode-everyday/index.html">
<meta property="og:site_name" content="陪小付度过漫长岁月">
<meta property="og:description" content="2024年 3月 1号_2369. 检查数组是否存在有效划分 给你一个下标从 0 开始的整数数组 nums ，你必须将数组划分为一个或多个 连续 子数组。 如果获得的这些子数组中每个都能满足下述条件 之一 ，则可以称其为数组的一种 有效 划分：  子数组 恰 由 2 个相等元素组成，例如，子数组 [2,2] 。 子数组 恰 由 3 个相等元素组成，例如，子数组 [4,4,4] 。 子数组 恰 由">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2024/02/25/zIWeRaZnF8Vxsqv.jpg">
<meta property="article:published_time" content="2024-03-02T16:00:00.000Z">
<meta property="article:modified_time" content="2025-07-10T14:12:27.102Z">
<meta property="article:author" content="anym0re">
<meta property="article:tag" content="代码">
<meta property="article:tag" content="python">
<meta property="article:tag" content="leetcode">
<meta property="article:tag" content="csdn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2024/02/25/zIWeRaZnF8Vxsqv.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "leetcode每日一题",
  "url": "http://anym0re.cn/2024/03/03/leetcode-everyday/",
  "image": "https://s2.loli.net/2024/02/25/zIWeRaZnF8Vxsqv.jpg",
  "datePublished": "2024-03-02T16:00:00.000Z",
  "dateModified": "2025-07-10T14:12:27.102Z",
  "author": [
    {
      "@type": "Person",
      "name": "anym0re",
      "url": "http://anym0re.cn"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://anym0re.cn/2024/03/03/leetcode-everyday/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="codeva-ofPgiBHacA"/><link rel="stylesheet" href="/css/index.css?v=5.4.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6b5bda8e65d88b63b357588907070664";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'leetcode每日一题',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/url(https:/s2.loli.net/2024/02/25/twedroK7pS9vbIy.jpg));"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://s2.loli.net/2024/02/25/zIWeRaZnF8Vxsqv.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera"></i><span> 相册</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fas fa-comment"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(https://s2.loli.net/2024/02/25/twedroK7pS9vbIy.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://s2.loli.net/2024/02/25/AjqPFYabZUBO638.png" alt="Logo"><span class="site-name">陪小付度过漫长岁月</span></a><a class="nav-page-title" href="/"><span class="site-name">leetcode每日一题</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera"></i><span> 相册</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fas fa-comment"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">leetcode每日一题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-02T16:00:00.000Z" title="发表于 2024-03-03 00:00:00">2024-03-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-10T14:12:27.102Z" title="更新于 2025-07-10 22:12:27">2025-07-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%BB%A3%E7%A0%81/">代码</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">20.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>85分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>2024年</h1>
<h2 id="3月">3月</h2>
<h3 id="1号-2369-检查数组是否存在有效划分">1号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/check-if-there-is-a-valid-partition-for-the-array/">2369. 检查数组是否存在有效划分</a></h3>
<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，你必须将数组划分为一个或多个 <strong>连续</strong> 子数组。</p>
<p>如果获得的这些子数组中每个都能满足下述条件 <strong>之一</strong> ，则可以称其为数组的一种 <strong>有效</strong> 划分：</p>
<ol>
<li>子数组 <strong>恰</strong> 由 <code>2</code> 个相等元素组成，例如，子数组 <code>[2,2]</code> 。</li>
<li>子数组 <strong>恰</strong> 由 <code>3</code> 个相等元素组成，例如，子数组 <code>[4,4,4]</code> 。</li>
<li>子数组 <strong>恰</strong> 由 <code>3</code> 个连续递增元素组成，并且相邻元素之间的差值为 <code>1</code> 。例如，子数组 <code>[3,4,5]</code> ，但是子数组 <code>[1,3,5]</code> 不符合要求。</li>
</ol>
<p>如果数组 <strong>至少</strong> 存在一种有效划分，返回 <code>true</code> ，否则，返回 <code>false</code> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">validPartition</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment">#动态规划,注意子数组为连续子数组，所以有效划分必须连在一起</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        f = [<span class="literal">True</span>] + [<span class="literal">False</span>] * n   <span class="comment">#f(i+1)表示能有效划分0-i</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> f[i-<span class="number">1</span>] <span class="keyword">and</span> x == nums[i-<span class="number">1</span>] <span class="keyword">or</span> \</span><br><span class="line">               i &gt; <span class="number">1</span> <span class="keyword">and</span> f[i-<span class="number">2</span>] <span class="keyword">and</span> (x == nums[i-<span class="number">1</span>] == nums[i-<span class="number">2</span>] <span class="keyword">or</span> </span><br><span class="line">                                   x == nums[i-<span class="number">1</span>]+<span class="number">1</span> == nums[i-<span class="number">2</span>]+<span class="number">2</span>):</span><br><span class="line">                f[i+<span class="number">1</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> f[n]</span><br></pre></td></tr></table></figure>
<h3 id="2号-2368-受限条件下可到达节点的数目">2号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reachable-nodes-with-restrictions/">2368. 受限条件下可到达节点的数目</a></h3>
<p>现有一棵由 <code>n</code> 个节点组成的无向树，节点编号从 <code>0</code> 到 <code>n - 1</code> ，共有 <code>n - 1</code> 条边。</p>
<p>给你一个二维整数数组 <code>edges</code> ，长度为 <code>n - 1</code> ，其中 <code>edges[i] = [ai, bi]</code> 表示树中节点 <code>ai</code> 和 <code>bi</code> 之间存在一条边。另给你一个整数数组 <code>restricted</code> 表示 <strong>受限</strong> 节点。</p>
<p>在不访问受限节点的前提下，返回你可以从节点 <code>0</code> 到达的 <strong>最多</strong> 节点数目*。*</p>
<p>注意，节点 <code>0</code> <strong>不</strong> 会标记为受限节点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reachableNodes</span>(<span class="params">self, n: <span class="built_in">int</span>, edges: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], restricted: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        restricted = <span class="built_in">set</span>(restricted)</span><br><span class="line">        road = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> edges:</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> restricted <span class="keyword">and</span> y <span class="keyword">not</span> <span class="keyword">in</span> restricted:   <span class="comment">#如果路之间不含无效节点，则连通</span></span><br><span class="line">                road[x].append(y)</span><br><span class="line">                road[y].append(x)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x: <span class="built_in">int</span>, rep:<span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:   <span class="comment">#dfs遍历</span></span><br><span class="line">            res = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> road[x]:</span><br><span class="line">                <span class="keyword">if</span> y != rep:        <span class="comment">#避免x,y与y,x重复递归</span></span><br><span class="line">                    res += dfs(y,x)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="3号-225-用队列实现栈">3号_225. 用队列实现栈</h3>
<p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。<br>
实现 MyStack 类：<br>
void push(int x) 将元素 x 压入栈顶。<br>
int pop() 移除并返回栈顶元素。<br>
int top() 返回栈顶元素。<br>
boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.lst=[]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.lst.append(<span class="built_in">int</span>(x))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.lst.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.lst[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> <span class="variable language_">self</span>.lst</span><br></pre></td></tr></table></figure>
<h1></h1>
<h3 id="4号-232-用栈实现队列">4号_232. 用栈实现队列</h3>
<p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：<br>
实现 MyQueue 类：<br>
void push(int x) 将元素 x 推到队列的末尾<br>
int pop() 从队列的开头移除并返回元素<br>
int peek() 返回队列开头的元素<br>
boolean empty() 如果队列为空，返回 true ；否则，返回 false</p>
<p>说明：<br>
你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。<br>
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.stack1 = []   <span class="comment">#输入栈</span></span><br><span class="line">        <span class="variable language_">self</span>.stack2 = []   <span class="comment">#输出栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:   </span><br><span class="line">        <span class="variable language_">self</span>.stack1.append(x)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.stack2:     <span class="comment">#如果输出栈为空，则将输入栈的元素放到输出栈，栈内元素的顺序逆转</span></span><br><span class="line">            <span class="keyword">while</span> <span class="variable language_">self</span>.stack1:</span><br><span class="line">                <span class="variable language_">self</span>.stack2.append(<span class="variable language_">self</span>.stack1.pop())</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.stack2.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.stack2:     <span class="comment">#如果输出栈为空，则将输入栈的元素放到输出栈，栈内元素的顺序逆转</span></span><br><span class="line">            <span class="keyword">while</span> <span class="variable language_">self</span>.stack1:</span><br><span class="line">                <span class="variable language_">self</span>.stack2.append(<span class="variable language_">self</span>.stack1.pop())            </span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.stack2[-<span class="number">1</span>]   <span class="comment">#输出栈的栈顶元素为队列开头的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> <span class="variable language_">self</span>.stack1 <span class="keyword">and</span> <span class="keyword">not</span> <span class="variable language_">self</span>.stack2</span><br></pre></td></tr></table></figure>
<h3 id="5号-1976-到达目的地的方案数">5号_1976.到达目的地的方案数</h3>
<p>你在一个城市里，城市由 <code>n</code> 个路口组成，路口编号为 <code>0</code> 到 <code>n - 1</code> ，某些路口之间有 <strong>双向</strong> 道路。输入保证你可以从任意路口出发到达其他任意路口，且任意两个路口之间最多有一条路。</p>
<p>给你一个整数 <code>n</code> 和二维整数数组 <code>roads</code> ，其中 <code>roads[i] = [ui, vi, timei]</code> 表示在路口 <code>ui</code> 和 <code>vi</code> 之间有一条需要花费 <code>timei</code> 时间才能通过的道路。你想知道花费 <strong>最少时间</strong> 从路口 <code>0</code> 出发到达路口 <code>n - 1</code> 的方案数。</p>
<p>请返回花费 <strong>最少时间</strong> 到达目的地的 <strong>路径数目</strong> 。由于答案可能很大，将结果对 <code>109 + 7</code> <strong>取余</strong> 后返回。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countPaths</span>(<span class="params">self, n: <span class="built_in">int</span>, roads: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">#不能用*定义矩阵，否者列表元素的内存地址相同</span></span><br><span class="line">        <span class="comment">#a = [[float(&#x27;inf&#x27;)] * n] * n  #inf表示无穷大</span></span><br><span class="line">        a = [[<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]   </span><br><span class="line">        <span class="comment">#a[x][y]表示x节点到y节点的距离，如果给定了，则为d，如果没给定，则为inf</span></span><br><span class="line">        <span class="keyword">for</span> x,y,d <span class="keyword">in</span> roads:</span><br><span class="line">            a[x][y] = d     </span><br><span class="line">            a[y][x] = d</span><br><span class="line">        dis = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * n   <span class="comment">#dis[x]表示0到x节点的最短距离</span></span><br><span class="line">        dis[<span class="number">0</span>] = <span class="number">0</span>   <span class="comment">#0节点到0节点的距离为0</span></span><br><span class="line">        f = [<span class="number">0</span>] * n     <span class="comment">#表示0到x节点共有f[x]种最短路径</span></span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>      <span class="comment">#默认0到0节点有一种路径</span></span><br><span class="line">        done = [<span class="literal">False</span>] * n   <span class="comment">#表示节点是否已计算最短距离</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            x = -<span class="number">1</span>  <span class="comment">#重置x，以便进行遍历</span></span><br><span class="line">            <span class="comment">#找出x节点邻点的最小dis[y]</span></span><br><span class="line">            <span class="keyword">for</span> i,do <span class="keyword">in</span> <span class="built_in">enumerate</span>(done):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> do <span class="keyword">and</span> (x&lt;<span class="number">0</span> <span class="keyword">or</span> dis[i]&lt;dis[x]):  </span><br><span class="line">                    x = i</span><br><span class="line">            <span class="keyword">if</span> x == n-<span class="number">1</span>:   <span class="comment">#当所有的节点都done了</span></span><br><span class="line">                <span class="keyword">return</span> f[-<span class="number">1</span>]   <span class="comment">#输出n-1节点最短路径数</span></span><br><span class="line">            dx = dis[x]     <span class="comment">#减少循环中调用dis[x]的次数</span></span><br><span class="line">            <span class="keyword">for</span> y,d <span class="keyword">in</span> <span class="built_in">enumerate</span>(a[x]):   <span class="comment">#将x节点的邻点y的dis(y)确认</span></span><br><span class="line">                new_dis = dx + d    <span class="comment">#从0到x再到y</span></span><br><span class="line">                <span class="comment">#如果从x走更短，更改dis[y]，并且令f[y]=f[x]</span></span><br><span class="line">                <span class="keyword">if</span> new_dis &lt; dis[y]:   </span><br><span class="line">                    dis[y] = new_dis</span><br><span class="line">                    f[y] = f[x]</span><br><span class="line">                <span class="comment">#如果从x走的长度一样，则y节点的最短路径加上f[x]条</span></span><br><span class="line">                <span class="keyword">elif</span> new_dis == dis[y]:   </span><br><span class="line">                    f[y] = (f[y] + f[x]) % <span class="number">1_000_000_007</span></span><br><span class="line">            done[x] = <span class="literal">True</span>   <span class="comment">#x节点已完成，标记为done      </span></span><br></pre></td></tr></table></figure>
<h3 id="6号-2917-找出数组中的-K-or-值">6号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-k-or-of-an-array/">2917. 找出数组中的 K-or 值</a></h3>
<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p>
<p><code>nums</code> 中的 <strong>K-or</strong> 是一个满足以下条件的非负整数：</p>
<ul>
<li>只有在 <code>nums</code> 中，至少存在 <code>k</code> 个元素的第 <code>i</code> 位值为 1 ，那么 K-or 中的第 <code>i</code> 位的值才是 1 。</li>
</ul>
<p>返回 <code>nums</code> 的 <strong>K-or</strong> 值。</p>
<p><strong>注意</strong> ：对于整数 <code>x</code> ，如果 <code>(2i AND x) == 2i</code> ，则 <code>x</code> 中的第 <code>i</code> 位值为 1 ，其中 <code>AND</code> 为按位与运算符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKOr</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        output = <span class="number">0</span>    </span><br><span class="line">        i = <span class="number">0</span>     <span class="comment">#用来判断位置</span></span><br><span class="line">        n = <span class="built_in">max</span>(nums)   </span><br><span class="line">        <span class="keyword">while</span> n&gt;&gt;i:   <span class="comment">#当i超过n的位数时终止循环</span></span><br><span class="line">            k_judge = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> item&gt;&gt;i &amp; <span class="number">1</span>:  <span class="comment">#判断item的第i位是否为1</span></span><br><span class="line">                        k_judge += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k_judge &gt;= k:</span><br><span class="line">                output += <span class="number">2</span>**i</span><br><span class="line">            i = i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>
<h3 id="7号-2575-找出字符串的可整除数组">7号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-divisibility-array-of-a-string/">2575. 找出字符串的可整除数组</a></h3>
<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>word</code> ，长度为 <code>n</code> ，由从 <code>0</code> 到 <code>9</code> 的数字组成。另给你一个正整数 <code>m</code> 。</p>
<p><code>word</code> 的 <strong>可整除数组</strong> <code>div</code> 是一个长度为 <code>n</code> 的整数数组，并满足：</p>
<ul>
<li>如果 <code>word[0,...,i]</code> 所表示的 <strong>数值</strong> 能被 <code>m</code> 整除，<code>div[i] = 1</code></li>
<li>否则，<code>div[i] = 0</code></li>
</ul>
<p>返回 <code>word</code> 的可整除数组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">divisibilityArray</span>(<span class="params">self, word: <span class="built_in">str</span>, m: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        rem = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(word)):</span><br><span class="line">            rem = (rem * <span class="number">10</span> + <span class="built_in">int</span>(word[i])) % m  <span class="comment">#word[:i]*10+word[i]=word[:i+1]=(nm+res)*10+word[i],n为整数</span></span><br><span class="line">            <span class="keyword">if</span> rem: res.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">else</span>: res.append(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="8号-2834-找出美丽数组的最小和">8号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-minimum-possible-sum-of-a-beautiful-array/">2834. 找出美丽数组的最小和</a></h3>
<p>给你两个正整数：<code>n</code> 和 <code>target</code> 。</p>
<p>如果数组 <code>nums</code> 满足下述条件，则称其为 <strong>美丽数组</strong> 。</p>
<ul>
<li><code>nums.length == n</code>.</li>
<li><code>nums</code> 由两两互不相同的正整数组成。</li>
<li>在范围 <code>[0, n-1]</code> 内，<strong>不存在</strong> 两个 <strong>不同</strong> 下标 <code>i</code> 和 <code>j</code> ，使得 <code>nums[i] + nums[j] == target</code> 。</li>
</ul>
<p>返回符合条件的美丽数组所可能具备的 <strong>最小</strong> 和，并对结果进行取模 <code>109 + 7</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumPossibleSum</span>(<span class="params">self, n: <span class="built_in">int</span>, target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        k = target // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= k:</span><br><span class="line">            <span class="keyword">return</span> (n+<span class="number">1</span>)*n//<span class="number">2</span> % (<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> ((k+<span class="number">1</span>)*k//<span class="number">2</span> + (<span class="number">2</span>*target+n-k-<span class="number">1</span>)*(n-k)//<span class="number">2</span>) % (<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<h3 id="9号-2386-找出数组的第-K-大和">9号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-k-sum-of-an-array/">2386. 找出数组的第 K 大和</a></h3>
<p>给你一个整数数组 <code>nums</code> 和一个 <strong>正</strong> 整数 <code>k</code> 。你可以选择数组的任一 <strong>子序列</strong> 并且对其全部元素求和。</p>
<p>数组的 <strong>第 k 大和</strong> 定义为：可以获得的第 <code>k</code> 个 <strong>最大</strong> 子序列和（子序列和允许出现重复）</p>
<p>返回数组的 <strong>第 k 大和</strong> 。</p>
<p>子序列是一个可以由其他数组删除某些或不删除元素排生而来的数组，且派生过程不改变剩余元素的顺序。</p>
<p>**注意：**空子序列的和视作 <code>0</code> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">#求出最大值s，并且把所有负数转为正数，这样统一只需要做减法即可</span></span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">sum</span> += x</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[i] = -x</span><br><span class="line">        nums.sort()</span><br><span class="line"></span><br><span class="line">        <span class="comment">#以累加和来排列子序列，排到第k个终止</span></span><br><span class="line">        stack = [(<span class="number">0</span>,<span class="number">0</span>)]  <span class="comment">#空子序列,一个用来装子序列和,一个装下标</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>):   <span class="comment">#已经有一个（0,0）,所以只需要循环k-1次</span></span><br><span class="line">            s, i = heappop(stack)</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(nums):   <span class="comment">#子序列下标不超过原序列下标</span></span><br><span class="line">                <span class="comment"># 在子序列的末尾添加 nums[i]</span></span><br><span class="line">                heappush(stack, (s + nums[i] , i+<span class="number">1</span>) )  <span class="comment"># 下一个添加/替换的元素下标为 i+1</span></span><br><span class="line">                <span class="keyword">if</span> i:   <span class="comment"># 替换子序列的末尾元素为 nums[i]</span></span><br><span class="line">                    heappush(stack, (s + nums[i] - nums[i-<span class="number">1</span>], i+<span class="number">1</span>) )</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span> - stack[<span class="number">0</span>][<span class="number">0</span>]        </span><br></pre></td></tr></table></figure>
<h3 id="10号-299-猜数字游戏">10号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/bulls-and-cows/">299. 猜数字游戏</a></h3>
<p>你在和朋友一起玩 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%8C%9C%E6%95%B0%E5%AD%97/83200?fromtitle=Bulls+and+Cows&amp;fromid=12003488&amp;fr=aladdin">猜数字（Bulls and Cows）</a>游戏，该游戏规则如下：</p>
<p>写出一个秘密数字，并请朋友猜这个数字是多少。朋友每猜测一次，你就会给他一个包含下述信息的提示：</p>
<ul>
<li>猜测数字中有多少位属于数字和确切位置都猜对了（称为 “Bulls”，公牛），</li>
<li>有多少位属于数字猜对了但是位置不对（称为 “Cows”，奶牛）。也就是说，这次猜测中有多少位非公牛数字可以通过重新排列转换成公牛数字。</li>
</ul>
<p>给你一个秘密数字 <code>secret</code> 和朋友猜测的数字 <code>guess</code> ，请你返回对朋友这次猜测的提示。</p>
<p>提示的格式为 <code>&quot;xAyB&quot;</code> ，<code>x</code> 是公牛个数， <code>y</code> 是奶牛个数，<code>A</code> 表示公牛，<code>B</code> 表示奶牛。</p>
<p>请注意秘密数字和朋友猜测的数字都可能含有重复数字。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getHint</span>(<span class="params">self, secret: <span class="built_in">str</span>, guess: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        bulls= <span class="number">0</span></span><br><span class="line">        s, g = Counter(), Counter()</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(secret, guess):</span><br><span class="line">            <span class="keyword">if</span> x == y:</span><br><span class="line">                bulls += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s[x] += <span class="number">1</span>   <span class="comment">#计数</span></span><br><span class="line">                g[y] += <span class="number">1</span>   <span class="comment">#计数</span></span><br><span class="line">        cows = (s &amp; g).total()   <span class="comment">#Counter函数的与：相同key保留且取最小值；total：把所有的值相加</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;bulls&#125;</span>A<span class="subst">&#123;cows&#125;</span>B&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="11号-2129-将标题首字母大写">11号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/capitalize-the-title/">2129. 将标题首字母大写</a></h3>
<p>给你一个字符串 <code>title</code> ，它由单个空格连接一个或多个单词组成，每个单词都只包含英文字母。请你按以下规则将每个单词的首字母 <strong>大写</strong> ：</p>
<ul>
<li>如果单词的长度为 <code>1</code> 或者 <code>2</code> ，所有字母变成小写。</li>
<li>否则，将单词首字母大写，剩余字母变成小写。</li>
</ul>
<p>请你返回 <strong>大写后</strong> 的 <code>title</code> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">capitalizeTitle</span>(<span class="params">self, title: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        title = title.lower().split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i,item <span class="keyword">in</span> <span class="built_in">enumerate</span>(title):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(item) &gt; <span class="number">2</span>:</span><br><span class="line">                title[i] = item[<span class="number">0</span>].upper() + item[<span class="number">1</span>:]   <span class="comment">#要变title而不是item</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(title)</span><br></pre></td></tr></table></figure>
<h3 id="12号-1261-在受污染的二叉树中查找元素">12号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-elements-in-a-contaminated-binary-tree/">1261. 在受污染的二叉树中查找元素</a></h3>
<p>给出一个满足下述规则的二叉树：</p>
<ol>
<li><code>root.val == 0</code></li>
<li>如果 <code>treeNode.val == x</code> 且 <code>treeNode.left != null</code>，那么 <code>treeNode.left.val == 2 * x + 1</code></li>
<li>如果 <code>treeNode.val == x</code> 且 <code>treeNode.right != null</code>，那么 <code>treeNode.right.val == 2 * x + 2</code></li>
</ol>
<p>现在这个二叉树受到「污染」，所有的 <code>treeNode.val</code> 都变成了 <code>-1</code>。</p>
<p>请你先还原二叉树，然后实现 <code>FindElements</code> 类：</p>
<ul>
<li><code>FindElements(TreeNode* root)</code> 用受污染的二叉树初始化对象，你需要先把它还原。</li>
<li><code>bool find(int target)</code> 判断目标值 <code>target</code> 是否存在于还原后的二叉树中并返回结果。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>):</span><br><span class="line">    <span class="comment">#实际上，如果可以直接输出find的话，不需要把受污染树完全还原</span></span><br><span class="line">    <span class="variable language_">self</span>.root = root   <span class="comment">#将输入值赋给类属性</span></span><br><span class="line">    <span class="variable language_">self</span>.root.val = <span class="number">0</span>  <span class="comment">#将根节点值改为0</span></span><br><span class="line">    queue = deque([<span class="variable language_">self</span>.root])</span><br><span class="line">    <span class="comment">#BFS遍历</span></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        node = queue.popleft()</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            node.left.val = node.val * <span class="number">2</span> + <span class="number">1</span>  <span class="comment">#更改左子树值</span></span><br><span class="line">            queue.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            node.right.val = node.val * <span class="number">2</span> + <span class="number">2</span> <span class="comment">#更改右子树值</span></span><br><span class="line">            queue.append(node.right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    lst = []  <span class="comment">#用作储存树遍历顺序的栈</span></span><br><span class="line">    <span class="keyword">while</span> target:  <span class="comment">#将顺序标识反向放入栈中</span></span><br><span class="line">        <span class="keyword">if</span> target % <span class="number">2</span>:</span><br><span class="line">            lst.append(<span class="number">1</span>)</span><br><span class="line">            target = (target - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            lst.append(<span class="number">0</span>)</span><br><span class="line">            target = (target - <span class="number">2</span>) // <span class="number">2</span></span><br><span class="line">    cur = <span class="variable language_">self</span>.root  <span class="comment">#用局部变量储存类属性</span></span><br><span class="line">    <span class="keyword">while</span> lst:</span><br><span class="line">        n = lst.pop()  <span class="comment">#从栈中拿出顺序标识，这时为正向拿出</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.left: cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">False</span> <span class="comment">#子树为空说明不存在</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.right: cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FindElements</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>):</span><br><span class="line">        s = <span class="built_in">set</span>()</span><br><span class="line">        <span class="comment">#dfs遍历</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            s.add(val) <span class="comment">#在遍历时就把所有节点值储存起来</span></span><br><span class="line">            dfs(node.left, val * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">            dfs(node.right, val * <span class="number">2</span> + <span class="number">2</span>)</span><br><span class="line">        dfs(root, <span class="number">0</span>)</span><br><span class="line">        <span class="variable language_">self</span>.s = s</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> target <span class="keyword">in</span> <span class="variable language_">self</span>.s</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#思路和方法一一致，使用位运算极大简化代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FindElements</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>):</span><br><span class="line">        <span class="variable language_">self</span>.root = root</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        target += <span class="number">1</span>  <span class="comment">#相当于将所有的节点数+1</span></span><br><span class="line">        cur = <span class="variable language_">self</span>.root  <span class="comment"># 从根节点出发</span></span><br><span class="line">        <span class="comment"># 从次高位开始枚举</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(target.bit_length() - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):  <span class="comment">#bit_length求二进制位数</span></span><br><span class="line">            bit = (target &gt;&gt; i) &amp; <span class="number">1</span>  <span class="comment"># target 第 i 位的比特值</span></span><br><span class="line">            cur = cur.right <span class="keyword">if</span> bit <span class="keyword">else</span> cur.left</span><br><span class="line">            <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 走到空节点，说明 target 不在二叉树中</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># 没有走到空节点，说明 target 在二叉树中</span></span><br></pre></td></tr></table></figure>
<h3 id="13号-2864-最大二进制奇数">13号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-odd-binary-number/">2864. 最大二进制奇数</a></h3>
<p>给你一个 <strong>二进制</strong> 字符串 <code>s</code> ，其中至少包含一个 <code>'1'</code> 。</p>
<p>你必须按某种方式 <strong>重新排列</strong> 字符串中的位，使得到的二进制数字是可以由该组合生成的 <strong>最大二进制奇数</strong> 。</p>
<p>以字符串形式，表示并返回可以由给定组合生成的最大二进制奇数。</p>
<p><strong>注意</strong> 返回的结果字符串 <strong>可以</strong> 含前导零。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumOddBinaryNumber</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        cnt = s.count(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span> * (cnt - <span class="number">1</span>) + <span class="string">&#x27;0&#x27;</span> * (<span class="built_in">len</span>(s) - cnt) + <span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="14号-2789-合并后数组中的最大元素">14号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-element-in-an-array-after-merge-operations/">2789. 合并后数组中的最大元素</a></h3>
<p>给你一个下标从 <strong>0</strong> 开始、由正整数组成的数组 <code>nums</code> 。</p>
<p>你可以在数组上执行下述操作 <strong>任意</strong> 次：</p>
<ul>
<li>选中一个同时满足 <code>0 &lt;= i &lt; nums.length - 1</code> 和 <code>nums[i] &lt;= nums[i + 1]</code> 的整数 <code>i</code> 。将元素 <code>nums[i + 1]</code> 替换为 <code>nums[i] + nums[i + 1]</code> ，并从数组中删除元素 <code>nums[i]</code> 。</li>
</ul>
<p>返回你可以从最终数组中获得的 <strong>最大</strong> 元素的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxArrayValue</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>):  <span class="comment">#反向遍历，不遍历0</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] &gt;= nums[i-<span class="number">1</span>]: <span class="comment">#满足条件则执行题中操作</span></span><br><span class="line">                nums[i-<span class="number">1</span>] += nums[i]            </span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]  <span class="comment">#如果nums[0]比nums[1]小，则会累加，如果nums[0]比nums[1]大，它本身就是最大的</span></span><br></pre></td></tr></table></figure>
<h3 id="15号-2312-卖木头块">15号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/selling-pieces-of-wood/">2312. 卖木头块</a></h3>
<p>给你两个整数 <code>m</code> 和 <code>n</code> ，分别表示一块矩形木块的高和宽。同时给你一个二维整数数组 <code>prices</code> ，其中 <code>prices[i] = [hi, wi, pricei]</code> 表示你可以以 <code>pricei</code> 元的价格卖一块高为 <code>hi</code> 宽为 <code>wi</code> 的矩形木块。</p>
<p>每一次操作中，你必须按下述方式之一执行切割操作，以得到两块更小的矩形木块：</p>
<ul>
<li>沿垂直方向按高度 <strong>完全</strong> 切割木块，或</li>
<li>沿水平方向按宽度 <strong>完全</strong> 切割木块</li>
</ul>
<p>在将一块木块切成若干小木块后，你可以根据 <code>prices</code> 卖木块。你可以卖多块同样尺寸的木块。你不需要将所有小木块都卖出去。你 <strong>不能</strong> 旋转切好后木块的高和宽。</p>
<p>请你返回切割一块大小为 <code>m x n</code> 的木块后，能得到的 <strong>最多</strong> 钱数。</p>
<p>注意你可以切割木块任意次。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#暴力枚举，一个高宽为ij的木板，有三种情况，横切竖切和自身</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sellingWood</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span>, prices: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        f = [[<span class="number">0</span>]* (n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> w, h, p <span class="keyword">in</span> prices:</span><br><span class="line">            f[w][h] = p</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j],</span><br><span class="line">                              <span class="built_in">max</span>((f[i][k]+f[i][j-k] <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, j // <span class="number">2</span> + <span class="number">1</span>)), default = <span class="number">0</span>), <span class="comment">#横向切割</span></span><br><span class="line">                              <span class="built_in">max</span>((f[k][j]+f[i-k][j] <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i// <span class="number">2</span> + <span class="number">1</span>)), default = <span class="number">0</span>))  <span class="comment">#纵向切割</span></span><br><span class="line">        <span class="keyword">return</span> f[m][n]                      </span><br></pre></td></tr></table></figure>
<h3 id="16号-2684-矩阵中移动的最大次数">16号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-number-of-moves-in-a-grid/">2684. 矩阵中移动的最大次数</a></h3>
<p>给你一个下标从 <strong>0</strong> 开始、大小为 <code>m x n</code> 的矩阵 <code>grid</code> ，矩阵由若干 <strong>正</strong> 整数组成。</p>
<p>你可以从矩阵第一列中的 <strong>任一</strong> 单元格出发，按以下方式遍历 <code>grid</code> ：</p>
<ul>
<li>从单元格 <code>(row, col)</code> 可以移动到 <code>(row - 1, col + 1)</code>、<code>(row, col + 1)</code> 和 <code>(row + 1, col + 1)</code> 三个单元格中任一满足值 <strong>严格</strong> 大于当前单元格的单元格。</li>
</ul>
<p>返回你在矩阵中能够 <strong>移动</strong> 的 <strong>最大</strong> 次数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#朴素dfs遍历，每个遍历返回长度，最后比较长度</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxMoves</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        f = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]  <span class="comment">#哈希表存储对应dfs值，避免重复遍历</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i,j</span>):  <span class="comment">#dfs遍历</span></span><br><span class="line">            res1, res2, res3 = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>  <span class="comment">#用来储存返回值，避免超出索引</span></span><br><span class="line">            <span class="keyword">if</span> j &gt;= n-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> grid[i][j] &lt; grid[i-<span class="number">1</span>][j+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> f[i-<span class="number">1</span>][j+<span class="number">1</span>]:  <span class="comment">#如果为0，则递归后续</span></span><br><span class="line">                    f[i-<span class="number">1</span>][j+<span class="number">1</span>] = dfs(i-<span class="number">1</span>,j+<span class="number">1</span>)</span><br><span class="line">                res1 = <span class="number">1</span> + f[i-<span class="number">1</span>][j+<span class="number">1</span>]  <span class="comment">#如果f[i-1][j+1]有值，直接使用</span></span><br><span class="line">            <span class="keyword">if</span> grid[i][j] &lt; grid[i][j+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> f[i][j+<span class="number">1</span>]:</span><br><span class="line">                    f[i][j+<span class="number">1</span>] = dfs(i,j+<span class="number">1</span>)</span><br><span class="line">                res2 = <span class="number">1</span> + f[i][j+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> i &lt; m-<span class="number">1</span> <span class="keyword">and</span> grid[i][j] &lt; grid[i+<span class="number">1</span>][j+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> f[i+<span class="number">1</span>][j+<span class="number">1</span>]:</span><br><span class="line">                    f[i+<span class="number">1</span>][j+<span class="number">1</span>] = dfs(i+<span class="number">1</span>,j+<span class="number">1</span>)</span><br><span class="line">                res3 = <span class="number">1</span> + f[i+<span class="number">1</span>][j+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(res1, res2, res3)</span><br><span class="line">        lst = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            lst.append(dfs(i,<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(lst)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#dfs遍历，直接输出最长长度</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxMoves</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i: <span class="built_in">int</span>, j: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, j)  <span class="comment">#只需要确定ans的最大值，函数不需要返回任何值</span></span><br><span class="line">            <span class="keyword">if</span> ans == n - <span class="number">1</span>:  <span class="comment"># ans 已达到最大值</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> i - <span class="number">1</span>, i, i + <span class="number">1</span>:  <span class="comment"># 向右上/右/右下走一步</span></span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= k &lt; m <span class="keyword">and</span> grid[k][j + <span class="number">1</span>] &gt; grid[i][j]:</span><br><span class="line">                    dfs(k, j + <span class="number">1</span>)</span><br><span class="line">            grid[i][j] = <span class="number">0</span>  <span class="comment">#使得后续遍历不再走该节点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            dfs(i, <span class="number">0</span>)  <span class="comment"># 从第一列的任一单元格出发</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#BFS遍历 </span></span><br><span class="line"><span class="comment">#一开始把所有 (i,0)(i,0)(i,0) 都加入一个列表。每一轮循环，遍历列表中的坐标，把右边这一列的能到达的格子坐标加入一个新列表。注意只有之前没入队的格子才能入队，，我们可以把要入队的格子值变为其相反数，从而判断哪些格子在队列中。此外，一个数一旦变成负数就不会比当前格子值大了，这可以保证一个格子值只会被标记（改成相反数）一次。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxMoves</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> grid:</span><br><span class="line">            row[<span class="number">0</span>] *= -<span class="number">1</span>  <span class="comment"># 入队标记</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i, row <span class="keyword">in</span> <span class="built_in">enumerate</span>(grid):</span><br><span class="line">                <span class="keyword">if</span> row[j] &gt; <span class="number">0</span>:  <span class="comment"># 不在队列中</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> i - <span class="number">1</span>, i, i + <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="number">0</span> &lt;= k &lt; m <span class="keyword">and</span> grid[k][j + <span class="number">1</span>] &gt; -row[j]:</span><br><span class="line">                        grid[k][j + <span class="number">1</span>] *= -<span class="number">1</span>  <span class="comment"># 入队标记</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">all</span>(row[j + <span class="number">1</span>] &gt; <span class="number">0</span> <span class="keyword">for</span> row <span class="keyword">in</span> grid):  <span class="comment"># 无法再往右走了</span></span><br><span class="line">                <span class="keyword">return</span> j</span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="17号-310-最小高度树">17号_310. 最小高度树</h3>
<p>给你一棵包含 n 个节点的树，标记为 0 到 n - 1 。给定数字 n 和一个有 n - 1 条无向边的 edges 列表（每一个边都是一对标签），其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 之间存在一条无向边。</p>
<p>可选择树中任何一个节点作为根。当选择节点 x 作为根节点时，设结果树的高度为 h 。在所有可能的树中，具有最小高度的树（即，min(h)）被称为 最小高度树 。</p>
<p>请你找到所有的 最小高度树 并按 任意顺序 返回它们的根节点标签列表。</p>
<p>树的 高度 是指根节点和叶子节点之间最长向下路径上边的数量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;原理：设起点为u，第一次BFS找到的终点v一定是树的直径的一个端点。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">证明：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果u 是直径上的点，则v必然是直径的终点。（因为如果v不是的话，则必定存在另一个点w使得u到w的距离更长，则于BFS找到了v矛盾）</span></span><br><span class="line"><span class="string">如果u不是直径上的点，则u到v的路径必然与树的直径相交，设交点为c，那么c到v的路径与直径的后半段重合。所以v一定是直径的一个端点，因此从v进行BFS得到的一定是直径长度。&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMinHeightTrees</span>(<span class="params">self, n: <span class="built_in">int</span>, edges: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        d = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> edges:</span><br><span class="line">            d[x].append(y)</span><br><span class="line">            d[y].append(x)</span><br><span class="line">        father = [<span class="number">0</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">start</span>):</span><br><span class="line">            vis = [<span class="literal">False</span>] * n</span><br><span class="line">            vis[start] = <span class="literal">True</span></span><br><span class="line">            qe = deque([start])</span><br><span class="line">            <span class="keyword">while</span> qe:</span><br><span class="line">                x = qe.popleft()</span><br><span class="line">                <span class="keyword">for</span> y <span class="keyword">in</span> d[x]:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> vis[y]: <span class="comment">#避免重复遍历</span></span><br><span class="line">                        vis[y] = <span class="literal">True</span></span><br><span class="line">                        father[y] = x <span class="comment">#记录父节点</span></span><br><span class="line">                        qe.append(y)</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="comment">#先找离起始点最远的点x，再找离x最远的点y，xy即为最远距离</span></span><br><span class="line">        x = bfs(<span class="number">0</span>)</span><br><span class="line">        y = bfs(x)</span><br><span class="line"></span><br><span class="line">        path = []</span><br><span class="line">        father[x] = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> y != -<span class="number">1</span>:</span><br><span class="line">            path.append(y)</span><br><span class="line">            y = father[y]</span><br><span class="line">        m = <span class="built_in">len</span>(path)</span><br><span class="line">        <span class="keyword">return</span> [path[m//<span class="number">2</span>]] <span class="keyword">if</span> m % <span class="number">2</span> <span class="keyword">else</span> [path[m//<span class="number">2</span> - <span class="number">1</span>], path[m//<span class="number">2</span>]]</span><br></pre></td></tr></table></figure>
<h3 id="18号-303-区域和检索-数组不可变">18号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-immutable/">303. 区域和检索 - 数组不可变</a></h3>
<p>给定一个整数数组  <code>nums</code>，处理以下类型的多个查询:</p>
<ol>
<li>计算索引 <code>left</code> 和 <code>right</code> （包含 <code>left</code> 和 <code>right</code>）之间的 <code>nums</code> 元素的 <strong>和</strong> ，其中 <code>left &lt;= right</code></li>
</ol>
<p>实现 <code>NumArray</code> 类：</p>
<ul>
<li><code>NumArray(int[] nums)</code> 使用数组 <code>nums</code> 初始化对象</li>
<li><code>int sumRange(int i, int j)</code> 返回数组 <code>nums</code> 中索引 <code>left</code> 和 <code>right</code> 之间的元素的 <strong>总和</strong> ，包含 <code>left</code> 和 <code>right</code> 两点（也就是 <code>nums[left] + nums[left + 1] + ... + nums[right]</code> )</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="variable language_">self</span>.s = [<span class="number">0</span>] * (n+<span class="number">1</span>)  <span class="comment">#为了避免nums(left)=0的情况，设s[0]=0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="variable language_">self</span>.s[i] = <span class="variable language_">self</span>.s[i-<span class="number">1</span>] + nums[i-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRange</span>(<span class="params">self, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.s[right+<span class="number">1</span>] - <span class="variable language_">self</span>.s[left] <span class="comment">#通过前缀和的差来输出累加和，使得时间复杂度为O(1)</span></span><br></pre></td></tr></table></figure>
<h3 id="19号-1793-好子数组的最大分数">19号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-score-of-a-good-subarray/">1793. 好子数组的最大分数</a></h3>
<p>给你一个整数数组 <code>nums</code> **（下标从 0 开始）**和一个整数 <code>k</code> 。</p>
<p>一个子数组 <code>(i, j)</code> 的 <strong>分数</strong> 定义为 <code>min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1)</code> 。一个 <strong>好</strong> 子数组的两个端点下标需要满足 <code>i &lt;= k &lt;= j</code> 。</p>
<p>请你返回 <strong>好</strong> 子数组的最大可能 <strong>分数</strong> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#双指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumScore</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        i = j = k</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        s = h = nums[k]</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):  <span class="comment">#必须遍历所有可能，而不是加终止条件</span></span><br><span class="line">            <span class="keyword">if</span> j == n-<span class="number">1</span> <span class="keyword">or</span> (i <span class="keyword">and</span> nums[i-<span class="number">1</span>] &gt;= nums[j+<span class="number">1</span>]): <span class="comment">#and的优先级比or高，实际上可以不加括号</span></span><br><span class="line">                h = <span class="built_in">min</span>(h,nums[i-<span class="number">1</span>])</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                h = <span class="built_in">min</span>(h,nums[j+<span class="number">1</span>])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(i,j,h,s)</span><br><span class="line">            s = <span class="built_in">max</span>(s, h*(j-i+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-non-zero-product-of-the-array-elements/">1969. 数组元素的最小非零乘积</a></p>
<p>给你一个正整数 <code>p</code> 。你有一个下标从 <strong>1</strong> 开始的数组 <code>nums</code> ，这个数组包含范围 <code>[1, 2p - 1]</code> 内所有整数的二进制形式（两端都 <strong>包含</strong>）。你可以进行以下操作 <strong>任意</strong> 次：</p>
<ul>
<li>从 <code>nums</code> 中选择两个元素 <code>x</code> 和 <code>y</code> 。</li>
<li>选择 <code>x</code> 中的一位与 <code>y</code> 对应位置的位交换。对应位置指的是两个整数 <strong>相同位置</strong> 的二进制位。</li>
</ul>
<p>比方说，如果 <code>x = 11***0***1</code> 且 <code>y = 00***1***1</code> ，交换右边数起第 <code>2</code> 位后，我们得到 <code>x = 11***1***1</code> 和 <code>y = 00***0***1</code> 。</p>
<p>请你算出进行以上操作 <strong>任意次</strong> 以后，<code>nums</code> 能得到的 <strong>最小非零</strong> 乘积。将乘积对 <code>109 + 7</code> <strong>取余</strong> 后返回。</p>
<p>**注意：**答案应为取余 <strong>之前</strong> 的最小值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minNonZeroProduct</span>(<span class="params">self, p: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">#本质是个算法问题，更像个数学问题</span></span><br><span class="line">        mod = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        m = <span class="number">2</span>**p - <span class="number">1</span></span><br><span class="line">        <span class="comment">#可以把除了2**p-1以外的项两辆配对，操作之后的最小配对乘积为(2**p - 2)**(2**(p-1) - 1)</span></span><br><span class="line">        <span class="keyword">return</span> (m * <span class="built_in">pow</span>(m-<span class="number">1</span>, m&gt;&gt;<span class="number">1</span>, mod)) % mod</span><br></pre></td></tr></table></figure>
<h3 id="21号-2671-频率跟踪器">21号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/frequency-tracker/">2671. 频率跟踪器</a></h3>
<p>请你设计并实现一个能够对其中的值进行跟踪的数据结构，并支持对频率相关查询进行应答。</p>
<p>实现 <code>FrequencyTracker</code> 类：</p>
<ul>
<li><code>FrequencyTracker()</code>：使用一个空数组初始化 <code>FrequencyTracker</code> 对象。</li>
<li><code>void add(int number)</code>：添加一个 <code>number</code> 到数据结构中。</li>
<li><code>void deleteOne(int number)</code>：从数据结构中删除一个 <code>number</code> 。数据结构 <strong>可能不包含</strong> <code>number</code> ，在这种情况下不删除任何内容。</li>
<li><code>bool hasFrequency(int frequency)</code>: 如果数据结构中存在出现 <code>frequency</code> 次的数字，则返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FrequencyTracker</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.cnt = Counter()   <span class="comment">#统计number出现频率</span></span><br><span class="line">        <span class="variable language_">self</span>.freq = Counter()  <span class="comment">#统计频率的出现次数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, number: <span class="built_in">int</span>, delta=<span class="number">1</span></span>) -&gt; <span class="literal">None</span>: <span class="comment">#delta默认为1，为delete嵌套做准备</span></span><br><span class="line">        <span class="variable language_">self</span>.freq[<span class="variable language_">self</span>.cnt[number]] -= <span class="number">1</span>  <span class="comment">#将number原频率的出现次数减一</span></span><br><span class="line">        <span class="variable language_">self</span>.cnt[number] += delta             <span class="comment">#将number频率加一</span></span><br><span class="line">        <span class="variable language_">self</span>.freq[<span class="variable language_">self</span>.cnt[number]] += <span class="number">1</span>  <span class="comment">#将number新频率的出现次数加一</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteOne</span>(<span class="params">self, number: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.cnt[number]:  <span class="comment">#如果number出现频率不为0，即number在数组中</span></span><br><span class="line">            <span class="variable language_">self</span>.add(number, -<span class="number">1</span>)  <span class="comment">#套用add函数，加上负一等于减一，Counter减到0会自动删除    </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasFrequency</span>(<span class="params">self, frequency: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.freq[frequency] &gt; <span class="number">0</span> <span class="comment">#如果不存在，Counter默认返回0</span></span><br><span class="line"><span class="comment"># Your FrequencyTracker object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = FrequencyTracker()</span></span><br><span class="line"><span class="comment"># obj.add(number)</span></span><br><span class="line"><span class="comment"># obj.deleteOne(number)</span></span><br><span class="line"><span class="comment"># param_3 = obj.hasFrequency(frequency)</span></span><br></pre></td></tr></table></figure>
<h3 id="22号-2617-网格图中最少访问的格子数">22号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-visited-cells-in-a-grid/">2617. 网格图中最少访问的格子数</a></h3>
<p>给你一个下标从 <strong>0</strong> 开始的 <code>m x n</code> 整数矩阵 <code>grid</code> 。你一开始的位置在 <strong>左上角</strong> 格子 <code>(0, 0)</code> 。</p>
<p>当你在格子 <code>(i, j)</code> 的时候，你可以移动到以下格子之一：</p>
<ul>
<li>满足 <code>j &lt; k &lt;= grid[i][j] + j</code> 的格子 <code>(i, k)</code> （向右移动），或者</li>
<li>满足 <code>i &lt; k &lt;= grid[i][j] + i</code> 的格子 <code>(k, j)</code> （向下移动）。</li>
</ul>
<p>请你返回到达 <strong>右下角</strong> 格子 <code>(m - 1, n - 1)</code> 需要经过的最少移动格子数，如果无法到达右下角格子，请你返回 <code>-1</code> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumVisitedCells</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">#明白思路了，暂时放弃查看代码</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        col_stacks = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]  <span class="comment"># 每列的单调栈</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            row_st = []  <span class="comment"># 当前行的单调栈</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                g = grid[i][j]</span><br><span class="line">                col_st = col_stacks[j]</span><br><span class="line">                mn = inf <span class="keyword">if</span> i &lt; m - <span class="number">1</span> <span class="keyword">or</span> j &lt; n - <span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> g:  <span class="comment"># 可以向右/向下跳</span></span><br><span class="line">                    <span class="comment"># 在单调栈上二分查找最优转移来源</span></span><br><span class="line">                    k = bisect_left(row_st, -(j + g), key=<span class="keyword">lambda</span> p: p[<span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">if</span> k &lt; <span class="built_in">len</span>(row_st):</span><br><span class="line">                        mn = row_st[k][<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">                    k = bisect_left(col_st, -(i + g), key=<span class="keyword">lambda</span> p: p[<span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">if</span> k &lt; <span class="built_in">len</span>(col_st):</span><br><span class="line">                        mn = <span class="built_in">min</span>(mn, col_st[k][<span class="number">0</span>] + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> mn &lt; inf:</span><br><span class="line">                    <span class="comment"># 插入单调栈</span></span><br><span class="line">                    <span class="keyword">while</span> row_st <span class="keyword">and</span> mn &lt;= row_st[-<span class="number">1</span>][<span class="number">0</span>]:</span><br><span class="line">                        row_st.pop()</span><br><span class="line">                    row_st.append((mn, -j))  <span class="comment"># 保证下标单调递增，方便调用 bisect_left</span></span><br><span class="line">                    <span class="keyword">while</span> col_st <span class="keyword">and</span> mn &lt;= col_st[-<span class="number">1</span>][<span class="number">0</span>]:</span><br><span class="line">                        col_st.pop()</span><br><span class="line">                    col_st.append((mn, -i))  <span class="comment"># 保证下标单调递增，方便调用 bisect_left</span></span><br><span class="line">        <span class="keyword">return</span> mn <span class="keyword">if</span> mn &lt; inf <span class="keyword">else</span> -<span class="number">1</span>  <span class="comment"># 最后一个算出的 mn 就是 f[0][0]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="23号-2549-统计桌面上的不同数字">23号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-distinct-numbers-on-board/">2549. 统计桌面上的不同数字</a></h3>
<p>给你一个正整数 <code>n</code> ，开始时，它放在桌面上。在 <code>109</code> 天内，每天都要执行下述步骤：</p>
<ul>
<li>对于出现在桌面上的每个数字 <code>x</code> ，找出符合 <code>1 &lt;= i &lt;= n</code> 且满足 <code>x % i == 1</code> 的所有数字 <code>i</code> 。</li>
<li>然后，将这些数字放在桌面上。</li>
</ul>
<p>返回在 <code>109</code> 天之后，出现在桌面上的 <strong>不同</strong> 整数的数目。</p>
<p><strong>注意：</strong></p>
<ul>
<li>一旦数字放在桌面上，则会一直保留直到结束。</li>
<li><code>%</code> 表示取余运算。例如，<code>14 % 3</code> 等于 <code>2</code> 。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">distinctIntegers</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> n-<span class="number">1</span> <span class="keyword">if</span> n&gt;<span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="24号-322-零钱兑换">24号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h3>
<p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (amount+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,amount+<span class="number">1</span>): <span class="comment">#先amount再coins是排列，先coins再amount是组合</span></span><br><span class="line">            <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">                <span class="keyword">if</span> coin &lt;= i:</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i], dp[i-coin]+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] &lt; <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"><span class="meta">        @cache </span><span class="comment">#缓存器</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i,a</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> a == <span class="number">0</span> <span class="keyword">else</span> inf</span><br><span class="line">            <span class="keyword">if</span> a &lt; coins[i]: <span class="keyword">return</span> dfs(i-<span class="number">1</span>,a)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(dfs(i-<span class="number">1</span>,a), dfs(i,a-coins[i])+<span class="number">1</span>)</span><br><span class="line">        ans = dfs(<span class="built_in">len</span>(coins)-<span class="number">1</span>, amount)</span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans &lt; inf <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="25号-518-零钱兑换-II">25号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change-ii/">518. 零钱兑换 II</a></h3>
<p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p>
<p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p>
<p>假设每一种面额的硬币有无限个。</p>
<p>题目数据保证结果符合 32 位带符号整数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">self, amount: <span class="built_in">int</span>, coins: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] * (amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins: <span class="comment">#先amount再coins是排列，先coins再amount是组合</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,amount+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i &gt;= coin:</span><br><span class="line">                    dp[i] += dp[i-coin]</span><br><span class="line">        <span class="keyword">return</span> dp[amount]</span><br></pre></td></tr></table></figure>
<h3 id="26号-2642-设计可以求最短路径的图类">26号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-graph-with-shortest-path-calculator/">2642. 设计可以求最短路径的图类</a></h3>
<p>给你一个有 <code>n</code> 个节点的 <strong>有向带权</strong> 图，节点编号为 <code>0</code> 到 <code>n - 1</code> 。图中的初始边用数组 <code>edges</code> 表示，其中 <code>edges[i] = [fromi, toi, edgeCosti]</code> 表示从 <code>fromi</code> 到 <code>toi</code> 有一条代价为 <code>edgeCosti</code> 的边。</p>
<p>请你实现一个 <code>Graph</code> 类：</p>
<ul>
<li><code>Graph(int n, int[][] edges)</code> 初始化图有 <code>n</code> 个节点，并输入初始边。</li>
<li><code>addEdge(int[] edge)</code> 向边集中添加一条边，其中 <code>edge = [from, to, edgeCost]</code> 。数据保证添加这条边之前对应的两个节点之间没有有向边。</li>
<li><code>int shortestPath(int node1, int node2)</code> 返回从节点 <code>node1</code> 到 <code>node2</code> 的路径 <strong>最小</strong> 代价。如果路径不存在，返回 <code>-1</code> 。一条路径的代价是路径中所有边代价之和</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n: <span class="built_in">int</span>, edges: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span><br><span class="line">        <span class="variable language_">self</span>.n = n</span><br><span class="line">        <span class="variable language_">self</span>.f = [[inf] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> x, y, d <span class="keyword">in</span> edges:</span><br><span class="line">            <span class="variable language_">self</span>.f[x][y] = d</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addEdge</span>(<span class="params">self, edge: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.f[edge[<span class="number">0</span>]][edge[<span class="number">1</span>]] = edge[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shortestPath</span>(<span class="params">self, node1: <span class="built_in">int</span>, node2: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        done = [<span class="literal">False</span>] * <span class="variable language_">self</span>.n</span><br><span class="line">        dist = [inf] * <span class="variable language_">self</span>.n</span><br><span class="line">        dist[node1] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            x = -<span class="number">1</span> <span class="comment">#重置x</span></span><br><span class="line">            <span class="keyword">for</span> i, do <span class="keyword">in</span> <span class="built_in">enumerate</span>(done):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> do <span class="keyword">and</span> (x&lt;<span class="number">0</span> <span class="keyword">or</span> dist[i] &lt; dist[x]):</span><br><span class="line">                    x = i  </span><br><span class="line">            <span class="keyword">if</span> x == node2: <span class="keyword">return</span> dist[node2] <span class="keyword">if</span> dist[node2] &lt; inf <span class="keyword">else</span> -<span class="number">1</span>  </span><br><span class="line">            <span class="keyword">for</span> y, d <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="variable language_">self</span>.f[x]):</span><br><span class="line">                new_dist = dist[x] + d</span><br><span class="line">                <span class="keyword">if</span> new_dist &lt; dist[y]:</span><br><span class="line">                    dist[y] = new_dist</span><br><span class="line">            done[x] = <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h3 id="27号-2580-统计将重叠区间合并成组的方案数">27号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-ways-to-group-overlapping-ranges/">2580. 统计将重叠区间合并成组的方案数</a></h3>
<p>给你一个二维整数数组 <code>ranges</code> ，其中 <code>ranges[i] = [starti, endi]</code> 表示 <code>starti</code> 到 <code>endi</code> 之间（包括二者）的所有整数都包含在第 <code>i</code> 个区间中。</p>
<p>你需要将 <code>ranges</code> 分成 <strong>两个</strong> 组（可以为空），满足：</p>
<ul>
<li>每个区间只属于一个组。</li>
<li>两个有 <strong>交集</strong> 的区间必须在 <strong>同一个</strong> 组内。</li>
</ul>
<p>如果两个区间有至少 <strong>一个</strong> 公共整数，那么这两个区间是 <strong>有交集</strong> 的。</p>
<ul>
<li>比方说，区间 <code>[1, 3]</code> 和 <code>[2, 5]</code> 有交集，因为 <code>2</code> 和 <code>3</code> 在两个区间中都被包含。</li>
</ul>
<p>请你返回将 <code>ranges</code> 划分成两个组的 <strong>总方案数</strong> 。由于答案可能很大，将它对 <code>109 + 7</code> <strong>取余</strong> 后返回。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countWays</span>(<span class="params">self, ranges: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ranges.sort(key = <span class="keyword">lambda</span> x: x[<span class="number">0</span>]) <span class="comment">#排序</span></span><br><span class="line">        res, max_r = <span class="number">1</span>, -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> l, r <span class="keyword">in</span> ranges:</span><br><span class="line">            <span class="keyword">if</span> l &gt; max_r: <span class="comment">#无法合并区间</span></span><br><span class="line">                res = res * <span class="number">2</span> % (<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>) <span class="comment">#每有一个无法合并的区间，就多一个独立区间</span></span><br><span class="line">            max_r = <span class="built_in">max</span>(max_r, r) <span class="comment">#更新区间右端点</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="28号-1997-访问完所有房间的第一天">28号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/first-day-where-you-have-been-in-all-the-rooms/">1997. 访问完所有房间的第一天</a></h3>
<p>你需要访问 <code>n</code> 个房间，房间从 <code>0</code> 到 <code>n - 1</code> 编号。同时，每一天都有一个日期编号，从 <code>0</code> 开始，依天数递增。你每天都会访问一个房间。</p>
<p>最开始的第 <code>0</code> 天，你访问 <code>0</code> 号房间。给你一个长度为 <code>n</code> 且 <strong>下标从 0 开始</strong> 的数组 <code>nextVisit</code> 。在接下来的几天中，你访问房间的 <strong>次序</strong> 将根据下面的 <strong>规则</strong> 决定：</p>
<ul>
<li>假设某一天，你访问 <code>i</code> 号房间。</li>
<li>如果算上本次访问，访问 <code>i</code> 号房间的次数为 <strong>奇数</strong> ，那么 <strong>第二天</strong> 需要访问 <code>nextVisit[i]</code> 所指定的房间，其中 <code>0 &lt;= nextVisit[i] &lt;= i</code> 。</li>
<li>如果算上本次访问，访问 <code>i</code> 号房间的次数为 <strong>偶数</strong> ，那么 <strong>第二天</strong> 需要访问 <code>(i + 1) mod n</code> 号房间。</li>
</ul>
<p>请返回你访问完所有房间的第一天的日期编号。题目数据保证总是存在这样的一天。由于答案可能很大，返回对 <code>109 + 7</code> 取余后的结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#动态规划，没规划出来</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">firstDayBeenInAllRooms</span>(<span class="params">self, nextVisit: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] * <span class="built_in">len</span>(nextVisit)</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">enumerate</span>(nextVisit[:-<span class="number">1</span>]):</span><br><span class="line">            dp[i+<span class="number">1</span>] = (dp[i] * <span class="number">2</span> - dp[j] + <span class="number">2</span> ) % <span class="number">1_000_000_007</span> </span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="29号-2908-元素和最小的山形三元组-I">29号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-i/">2908. 元素和最小的山形三元组 I</a></h3>
<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。</p>
<p>如果下标三元组 <code>(i, j, k)</code> 满足下述全部条件，则认为它是一个 <strong>山形三元组</strong> ：</p>
<ul>
<li><code>i &lt; j &lt; k</code></li>
<li><code>nums[i] &lt; nums[j]</code> 且 <code>nums[k] &lt; nums[j]</code></li>
</ul>
<p>请你找出 <code>nums</code> 中 <strong>元素和最小</strong> 的山形三元组，并返回其 <strong>元素和</strong> 。如果不存在满足条件的三元组，返回 <code>-1</code> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#时间O(N2),空间O(1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">            m, l, r =nums[i], <span class="built_in">min</span>(nums[:i]), <span class="built_in">min</span>(nums[i+<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">if</span> l&lt;m <span class="keyword">and</span> r&lt;m: res = <span class="built_in">min</span>(res, l+r+m)</span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res &lt; <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#时间O(N),空间O(N)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        suf = [<span class="number">0</span>] * n</span><br><span class="line">        suf[-<span class="number">1</span>] = nums[-<span class="number">1</span>]  <span class="comment"># 后缀最小值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">2</span>, <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            suf[i] = <span class="built_in">min</span>(suf[i + <span class="number">1</span>], nums[i])</span><br><span class="line"></span><br><span class="line">        ans = inf</span><br><span class="line">        pre = nums[<span class="number">0</span>]  <span class="comment"># 前缀最小值</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> pre &lt; nums[j] &gt; suf[j + <span class="number">1</span>]:  <span class="comment"># 山形</span></span><br><span class="line">                ans = <span class="built_in">min</span>(ans, pre + nums[j] + suf[j + <span class="number">1</span>])  <span class="comment"># 更新答案</span></span><br><span class="line">            pre = <span class="built_in">min</span>(pre, nums[j])</span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans &lt; inf <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="30号-2952-需要添加的硬币的最小数量">30号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-coins-to-be-added/">2952. 需要添加的硬币的最小数量</a></h3>
<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>coins</code>，表示可用的硬币的面值，以及一个整数 <code>target</code> 。</p>
<p>如果存在某个 <code>coins</code> 的子序列总和为 <code>x</code>，那么整数 <code>x</code> 就是一个 <strong>可取得的金额</strong> 。</p>
<p>返回需要添加到数组中的 <strong>任意面值</strong> 硬币的 <strong>最小数量</strong> ，使范围 <code>[1, target]</code> 内的每个整数都属于 <strong>可取得的金额</strong> 。</p>
<p>数组的 <strong>子序列</strong> 是通过删除原始数组的一些（<strong>可能不删除</strong>）元素而形成的新的 <strong>非空</strong> 数组，删除过程不会改变剩余元素的相对位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumAddedCoins</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        coins.sort()</span><br><span class="line">        s, i, res = <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> s &lt;= target: <span class="comment">#贪心，考虑每个coin[i]所能覆盖的范围</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(coins) <span class="keyword">and</span> coins[i] &lt;= s: </span><br><span class="line">                s += coins[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s *= <span class="number">2</span></span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="31号-331-验证二叉树的前序序列化">31号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/verify-preorder-serialization-of-a-binary-tree/">331. 验证二叉树的前序序列化</a></h3>
<p>序列化二叉树的一种方法是使用 <strong>前序遍历</strong> 。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 <code>#</code>。</p>
<p>例如，上面的二叉树可以被序列化为字符串 <code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code>，其中 <code>#</code> 代表一个空节点。</p>
<p>给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。</p>
<p><strong>保证</strong> 每个以逗号分隔的字符或为一个整数或为一个表示 <code>null</code> 指针的 <code>'#'</code> 。</p>
<p>你可以认为输入格式总是有效的</p>
<ul>
<li>例如它永远不会包含两个连续的逗号，比如 <code>&quot;1,,3&quot;</code> 。</li>
</ul>
<p>**注意：**不允许重建树。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#队列</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidSerialization</span>(<span class="params">self, preorder: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        preorder = preorder.split(<span class="string">&#x27;,&#x27;</span>)[::-<span class="number">1</span>]</span><br><span class="line">        que = deque([preorder.pop()])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            node = que.popleft()</span><br><span class="line">            <span class="keyword">if</span> node != <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(preorder) &lt;= <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                que.append(preorder.pop())</span><br><span class="line">                que.append(preorder.pop())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span> <span class="keyword">if</span> preorder <span class="keyword">else</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#栈</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidSerialization</span>(<span class="params">self, preorder</span>):</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> preorder.split(<span class="string">&#x27;,&#x27;</span>):</span><br><span class="line">            stack.append(node)</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(stack) &gt;= <span class="number">3</span> <span class="keyword">and</span> stack[-<span class="number">1</span>] == stack[-<span class="number">2</span>] == <span class="string">&#x27;#&#x27;</span> <span class="keyword">and</span> stack[-<span class="number">3</span>] != <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                stack.pop(), stack.pop(), stack.pop()</span><br><span class="line">                stack.append(<span class="string">&#x27;#&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="4月">4月</h2>
<h3 id="1号-2810-故障键盘">1号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/faulty-keyboard/">2810. 故障键盘</a></h3>
<p>你的笔记本键盘存在故障，每当你在上面输入字符 <code>'i'</code> 时，它会反转你所写的字符串。而输入其他字符则可以正常工作。</p>
<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code> ，请你用故障键盘依次输入每个字符。</p>
<p>返回最终笔记本屏幕上输出的字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#暴力</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">finalString</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> item == <span class="string">&#x27;i&#x27;</span>: ans = ans[::-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>: ans.append(item)               </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(ans)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#双向队列</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">finalString</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        qe = deque()</span><br><span class="line">        tail = <span class="literal">True</span> <span class="comment">#判断从尾部加元素还是从头部加</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">                tail = <span class="keyword">not</span> tail <span class="comment">#修改方向</span></span><br><span class="line">            <span class="keyword">elif</span> tail:</span><br><span class="line">                qe.append(c)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                qe.appendleft(c)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(qe <span class="keyword">if</span> tail <span class="keyword">else</span> <span class="built_in">reversed</span>(qe))</span><br></pre></td></tr></table></figure>
<h3 id="2号-894-所有可能的真二叉树">2号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/all-possible-full-binary-trees/">894. 所有可能的真二叉树</a></h3>
<p>给你一个整数 <code>n</code> ，请你找出所有可能含 <code>n</code> 个节点的 <strong>真二叉树</strong> ，并以列表形式返回。答案中每棵树的每个节点都必须符合 <code>Node.val == 0</code> 。</p>
<p>答案的每个元素都是一棵真二叉树的根节点。你可以按 <strong>任意顺序</strong> 返回最终的真二叉树列表**。**</p>
<p><strong>真二叉树</strong> 是一类二叉树，树中每个节点恰好有 <code>0</code> 或 <code>2</code> 个子节点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#分治，递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"><span class="meta">    @cache</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">allPossibleFBT</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">Optional</span>[TreeNode]]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>: <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>: </span><br><span class="line">            res.append(TreeNode(<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> res   </span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n,<span class="number">2</span>):</span><br><span class="line">            left = <span class="variable language_">self</span>.allPossibleFBT(k)</span><br><span class="line">            right = <span class="variable language_">self</span>.allPossibleFBT(n-<span class="number">1</span>-k)</span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> left:</span><br><span class="line">                <span class="keyword">for</span> r <span class="keyword">in</span> right:</span><br><span class="line">                    node = TreeNode(<span class="number">0</span>,l,r)</span><br><span class="line">                    res.append(node)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#dp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">allPossibleFBT</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">Optional</span>[TreeNode]]:</span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>: <span class="keyword">return</span> []</span><br><span class="line">        l = n//<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        dp = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(l)]</span><br><span class="line">        dp[<span class="number">0</span>] = [TreeNode(<span class="number">0</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,l):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> dp[j]:</span><br><span class="line">                    <span class="keyword">for</span> r <span class="keyword">in</span> dp[i-j-<span class="number">1</span>]:</span><br><span class="line">                        dp[i].append(TreeNode(<span class="number">0</span>,l,r))</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="3号-1379-找出克隆二叉树中的相同节点">3号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/">1379. 找出克隆二叉树中的相同节点</a></h3>
<p>给你两棵二叉树，原始树 <code>original</code> 和克隆树 <code>cloned</code>，以及一个位于原始树 <code>original</code> 中的目标节点 <code>target</code>。</p>
<p>其中，克隆树 <code>cloned</code> 是原始树 <code>original</code> 的一个 <strong>副本</strong> 。</p>
<p>请找出在树 <code>cloned</code> 中，与 <code>target</code> <strong>相同</strong> 的节点，并返回对该节点的引用（在 C/C++ 等有指针的语言中返回 节点指针，其他语言返回节点本身）。</p>
<p>**注意：**你 <strong>不能</strong> 对两棵二叉树，以及 <code>target</code> 节点进行更改。<strong>只能</strong> 返回对克隆树 <code>cloned</code> 中已有的节点的引用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getTargetCopy</span>(<span class="params">self, original: TreeNode, cloned: TreeNode, target: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> original: <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> original == target: <span class="keyword">return</span> cloned</span><br><span class="line">        <span class="comment">#cloned是克隆树，和original不同，不能让它们相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.getTargetCopy(original.left, cloned.left, target) <span class="keyword">or</span> \</span><br><span class="line">               <span class="variable language_">self</span>.getTargetCopy(original.right, cloned.right, target)</span><br></pre></td></tr></table></figure>
<h3 id="4号-2192-有向无环图中一个节点的所有祖先">4号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/">2192. 有向无环图中一个节点的所有祖先</a></h3>
<p>给你一个正整数 <code>n</code> ，它表示一个 <strong>有向无环图</strong> 中节点的数目，节点编号为 <code>0</code> 到 <code>n - 1</code> （包括两者）。</p>
<p>给你一个二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [fromi, toi]</code> 表示图中一条从 <code>fromi</code> 到 <code>toi</code> 的单向边。</p>
<p>请你返回一个数组 <code>answer</code>，其中 <code>answer[i]</code>是第 <code>i</code> 个节点的所有 <strong>祖先</strong> ，这些祖先节点 <strong>升序</strong> 排序。</p>
<p>如果 <code>u</code> 通过一系列边，能够到达 <code>v</code> ，那么我们称节点 <code>u</code> 是节点 <code>v</code> 的 <strong>祖先</strong> 节点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#正向dfs，把start节点放到每个后续节点的ans中，每个节点作为start遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getAncestors</span>(<span class="params">self, n: <span class="built_in">int</span>, edges: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        g = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> edges:</span><br><span class="line">            g[x].append(y)</span><br><span class="line">        ans = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        visit = [-<span class="number">1</span>] * n</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x</span>):</span><br><span class="line">            visit[x] = start</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> g[x]:</span><br><span class="line">                <span class="keyword">if</span> visit[y] != start:</span><br><span class="line">                    ans[y].append(start)</span><br><span class="line">                    dfs(y)</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">for</span> start <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            dfs(start)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#逆向dfs</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getAncestors</span>(<span class="params">self, n: <span class="built_in">int</span>, edges: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        g = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> edges:</span><br><span class="line">            g[y].append(x)  <span class="comment">#反向dfs</span></span><br><span class="line">        ans = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">y</span>):</span><br><span class="line">            visit[y] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> g[y]:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> visit[x]:</span><br><span class="line">                    dfs(x)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            visit = [<span class="literal">False</span>] * n</span><br><span class="line">            dfs(i)</span><br><span class="line">            visit[i] = <span class="literal">False</span> <span class="comment">#除了起始点以外的途径点都为True</span></span><br><span class="line">            ans[i] = [j <span class="keyword">for</span> j,b <span class="keyword">in</span> <span class="built_in">enumerate</span>(visit) <span class="keyword">if</span> b] <span class="comment">#将途经点添加</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="5号-1026-节点与其祖先之间的最大差值">5号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor/">1026. 节点与其祖先之间的最大差值</a></h3>
<p>给定二叉树的根节点 <code>root</code>，找出存在于 <strong>不同</strong> 节点 <code>A</code> 和 <code>B</code> 之间的最大值 <code>V</code>，其中 <code>V = |A.val - B.val|</code>，且 <code>A</code> 是 <code>B</code> 的祖先。</p>
<p>（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#递+最大最小值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxAncestorDiff</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root, mn, mx</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: </span><br><span class="line">                <span class="keyword">nonlocal</span> res</span><br><span class="line">                res = <span class="built_in">max</span>(res, mx - mn)</span><br><span class="line">                <span class="keyword">return</span>       </span><br><span class="line">            mn = <span class="built_in">min</span>(mn, root.val)</span><br><span class="line">            mx = <span class="built_in">max</span>(mx, root.val)          </span><br><span class="line">            dfs(root.left, mn, mx)</span><br><span class="line">            dfs(root.right, mn, mx)</span><br><span class="line">        dfs(root, root.val, root.val)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#归+最大最小值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxAncestorDiff</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: </span><br><span class="line">                <span class="keyword">return</span> inf, -inf</span><br><span class="line">            l_mn, l_mx = dfs(root.left)</span><br><span class="line">            r_mn, r_mx = dfs(root.right)</span><br><span class="line">            mn = <span class="built_in">min</span>(root.val, l_mn, r_mn)</span><br><span class="line">            mx = <span class="built_in">max</span>(root.val, l_mx, r_mx)</span><br><span class="line">            <span class="keyword">nonlocal</span> res</span><br><span class="line">            res = <span class="built_in">max</span>(res, root.val-mn, mx-root.val)          </span><br><span class="line">            <span class="keyword">return</span> mn, mx</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="6号-1483-树节点的第-K-个祖先">6号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/">1483. 树节点的第 K 个祖先</a></h3>
<p>给你一棵树，树上有 <code>n</code> 个节点，按从 <code>0</code> 到 <code>n-1</code> 编号。树以父节点数组的形式给出，其中 <code>parent[i]</code> 是节点 <code>i</code> 的父节点。树的根节点是编号为 <code>0</code> 的节点。</p>
<p>树节点的第 <em><code>k</code></em> 个祖先节点是从该节点到根节点路径上的第 <code>k</code> 个节点。</p>
<p>实现 <code>TreeAncestor</code> 类：</p>
<ul>
<li><code>TreeAncestor（int n， int[] parent）</code> 对树和父数组中的节点数初始化对象。</li>
<li><code>getKthAncestor``(int node, int k)</code> 返回节点 <code>node</code> 的第 <code>k</code> 个祖先节点。如果不存在这样的祖先节点，返回 <code>-1</code> 。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeAncestor</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n: <span class="built_in">int</span>, parent: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        m = n.bit_length() - <span class="number">1</span> <span class="comment">#位数减1</span></span><br><span class="line">        pa = [[p] + [-<span class="number">1</span>] * m <span class="keyword">for</span> p <span class="keyword">in</span> parent] <span class="comment">#有点dp的思想在里面</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> pa[i][j] != -<span class="number">1</span>: <span class="comment">#等于-1说明已经越过根节点，无需再找爷节点</span></span><br><span class="line">                    pa[i][j+<span class="number">1</span>] = pa[pa[i][j]][j]</span><br><span class="line">        <span class="variable language_">self</span>.pa = pa       </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getKthAncestor</span>(<span class="params">self, node: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k.bit_length()):</span><br><span class="line">            <span class="keyword">if</span> (k &gt;&gt; i) &amp; <span class="number">1</span>: </span><br><span class="line">                node = <span class="variable language_">self</span>.pa[node][i]</span><br><span class="line">                <span class="keyword">if</span> node == -<span class="number">1</span>: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>
<h3 id="7号-1600-王位继承顺序">7号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/throne-inheritance/">1600. 王位继承顺序</a></h3>
<p>一个王国里住着国王、他的孩子们、他的孙子们等等。每一个时间点，这个家庭里有人出生也有人死亡。</p>
<p>这个王国有一个明确规定的王位继承顺序，第一继承人总是国王自己。我们定义递归函数 <code>Successor(x, curOrder)</code> ，给定一个人 <code>x</code> 和当前的继承顺序，该函数返回 <code>x</code> 的下一继承人。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Successor(x, curOrder):</span><br><span class="line">    如果 x 没有孩子或者所有 x 的孩子都在 curOrder 中：</span><br><span class="line">        如果 x 是国王，那么返回 null</span><br><span class="line">        否则，返回 Successor(x 的父亲, curOrder)</span><br><span class="line">    否则，返回 x 不在 curOrder 中最年长的孩子</span><br></pre></td></tr></table></figure>
<p>比方说，假设王国由国王，他的孩子 Alice 和 Bob （Alice 比 Bob 年长）和 Alice 的孩子 Jack 组成。</p>
<ol>
<li>一开始， <code>curOrder</code> 为 <code>[&quot;king&quot;]</code>.</li>
<li>调用 <code>Successor(king, curOrder)</code> ，返回 Alice ，所以我们将 Alice 放入 <code>curOrder</code> 中，得到 <code>[&quot;king&quot;, &quot;Alice&quot;]</code> 。</li>
<li>调用 <code>Successor(Alice, curOrder)</code> ，返回 Jack ，所以我们将 Jack 放入 <code>curOrder</code> 中，得到 <code>[&quot;king&quot;, &quot;Alice&quot;, &quot;Jack&quot;]</code> 。</li>
<li>调用 <code>Successor(Jack, curOrder)</code> ，返回 Bob ，所以我们将 Bob 放入 <code>curOrder</code> 中，得到 <code>[&quot;king&quot;, &quot;Alice&quot;, &quot;Jack&quot;, &quot;Bob&quot;]</code> 。</li>
<li>调用 <code>Successor(Bob, curOrder)</code> ，返回 <code>null</code> 。最终得到继承顺序为 <code>[&quot;king&quot;, &quot;Alice&quot;, &quot;Jack&quot;, &quot;Bob&quot;]</code> 。</li>
</ol>
<p>通过以上的函数，我们总是能得到一个唯一的继承顺序。</p>
<p>请你实现 <code>ThroneInheritance</code> 类：</p>
<ul>
<li><code>ThroneInheritance(string kingName)</code> 初始化一个 <code>ThroneInheritance</code> 类的对象。国王的名字作为构造函数的参数传入。</li>
<li><code>void birth(string parentName, string childName)</code> 表示 <code>parentName</code> 新拥有了一个名为 <code>childName</code> 的孩子。</li>
<li><code>void death(string name)</code> 表示名为 <code>name</code> 的人死亡。一个人的死亡不会影响 <code>Successor</code> 函数，也不会影响当前的继承顺序。你可以只将这个人标记为死亡状态。</li>
<li><code>string[] getInheritanceOrder()</code> 返回 <strong>除去</strong> 死亡人员的当前继承顺序列表</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThroneInheritance</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, kingName: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.king = kingName</span><br><span class="line">        <span class="variable language_">self</span>.son = &#123;kingName:[]&#125;</span><br><span class="line">        <span class="variable language_">self</span>.dead = <span class="built_in">set</span>() <span class="comment">#不能和后面的death函数重名</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">birth</span>(<span class="params">self, parentName: <span class="built_in">str</span>, childName: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.son[parentName].append(childName)</span><br><span class="line">        <span class="variable language_">self</span>.son[childName] = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">death</span>(<span class="params">self, name: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.dead.add(name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getInheritanceOrder</span>(<span class="params">self</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">cur</span>):</span><br><span class="line">            <span class="keyword">if</span> cur <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.dead:</span><br><span class="line">                res.append(cur)</span><br><span class="line">            <span class="keyword">for</span> son <span class="keyword">in</span> <span class="variable language_">self</span>.son[cur]:</span><br><span class="line">                dfs(son)</span><br><span class="line">        res = []</span><br><span class="line">        dfs(<span class="variable language_">self</span>.king)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="8号-2009-使数组连续的最少操作数">8号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-operations-to-make-array-continuous/">2009. 使数组连续的最少操作数</a></h3>
<p>给你一个整数数组 <code>nums</code> 。每一次操作中，你可以将 <code>nums</code> 中 <strong>任意</strong> 一个元素替换成 <strong>任意</strong> 整数。</p>
<p>如果 <code>nums</code> 满足以下条件，那么它是 <strong>连续的</strong> ：</p>
<ul>
<li><code>nums</code> 中所有元素都是 <strong>互不相同</strong> 的。</li>
<li><code>nums</code> 中 <strong>最大</strong> 元素与 <strong>最小</strong> 元素的差等于 <code>nums.length - 1</code> 。</li>
</ul>
<p>比方说，<code>nums = [4, 2, 5, 3]</code> 是 <strong>连续的</strong> ，但是 <code>nums = [1, 2, 3, 5, 6]</code> <strong>不是连续的</strong> 。</p>
<p>请你返回使 <code>nums</code> <strong>连续</strong> 的 <strong>最少</strong> 操作次数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先去重排序，然后找到可操作最长连续子数组</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minOperations</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums) <span class="comment">#元素总个数</span></span><br><span class="line">        nums = <span class="built_in">list</span>(<span class="built_in">set</span>(nums))</span><br><span class="line">        m = <span class="built_in">len</span>(nums) <span class="comment">#不重复元素个数</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        max_len = dp = <span class="number">1</span>                </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">if</span> nums[i] + <span class="number">1</span> - nums[i-dp] &lt;= n : <span class="comment">#子数组不连续处空的元素可以由数组中其他元素补充</span></span><br><span class="line">                dp += <span class="number">1</span>  </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i-dp+<span class="number">1</span>, i+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> nums[i] + <span class="number">1</span> - nums[j] &lt;= n:</span><br><span class="line">                        dp = i-j+<span class="number">1</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            max_len = <span class="built_in">max</span>(max_len, dp)</span><br><span class="line">        <span class="keyword">return</span> n - max_len</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先去重排序，滑动窗口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minOperations</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums) <span class="comment">#元素总个数</span></span><br><span class="line">        nums = <span class="built_in">list</span>(<span class="built_in">set</span>(nums))</span><br><span class="line">        m = <span class="built_in">len</span>(nums) <span class="comment">#不重复元素个数</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        max_len = tmp = <span class="number">1</span></span><br><span class="line">        i = j = <span class="number">0</span>             </span><br><span class="line">        <span class="keyword">while</span> j &lt; m:</span><br><span class="line">            tmp = j - i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[j] - nums[i] + <span class="number">1</span> &gt; n: </span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                tmp -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            max_len = <span class="built_in">max</span>(max_len, tmp)</span><br><span class="line">        <span class="keyword">return</span> n - max_len</span><br></pre></td></tr></table></figure>
<h3 id="9号-2529-正整数和负整数的最大计数">9号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/">2529. 正整数和负整数的最大计数</a></h3>
<p>给你一个按 <strong>非递减顺序</strong> 排列的数组 <code>nums</code> ，返回正整数数目和负整数数目中的最大值。</p>
<ul>
<li>换句话讲，如果 <code>nums</code> 中正整数的数目是 <code>pos</code> ，而负整数的数目是 <code>neg</code> ，返回 <code>pos</code> 和 <code>neg</code>二者中的最大值。</li>
</ul>
<p><strong>注意：</strong><code>0</code> 既不是正整数也不是负整数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumCount</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        positive = negative = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num &gt; <span class="number">0</span>: positive += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> num &lt; <span class="number">0</span>: negative += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(positive, negative)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#二分</span></span><br><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumCount</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        neg = bisect_left(nums, <span class="number">0</span>)</span><br><span class="line">        pos = <span class="built_in">len</span>(nums) - bisect_right(nums, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(neg, pos)</span><br></pre></td></tr></table></figure>
<h3 id="10号-1702-修改后的最大二进制字符串">10号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-string-after-change/">1702. 修改后的最大二进制字符串</a></h3>
<p>给你一个二进制字符串 <code>binary</code> ，它仅有 <code>0</code> 或者 <code>1</code> 组成。你可以使用下面的操作任意次对它进行修改：</p>
<ul>
<li>操作 1 ：如果二进制串包含子字符串 “00”，你可以用 &quot;10&quot;将其替换。
<ul>
<li>比方说， <code>&quot;**00**010&quot; -&gt; &quot;**10**010&quot;</code></li>
</ul>
</li>
<li>操作 2 ：如果二进制串包含子字符串 “10”，你可以用 &quot;01&quot;将其替换。
<ul>
<li>比方说， <code>&quot;000**10**&quot; -&gt; &quot;000**01**&quot;</code></li>
</ul>
</li>
</ul>
<p>请你返回执行上述操作任意次以后能得到的 <strong>最大二进制字符串</strong> 。如果二进制字符串 <code>x</code> 对应的十进制数字大于二进制字符串 <code>y</code> 对应的十进制数字，那么我们称二进制字符串 <code>x</code> 大于二进制字符串 <code>y</code> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumBinaryString</span>(<span class="params">self, binary: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        i = binary.find(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span>:  <span class="comment"># binary 全是 &#x27;1&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> binary</span><br><span class="line">        cnt1 = binary.count(<span class="string">&#x27;1&#x27;</span>, i)  <span class="comment"># 统计 binary[i:] 中 &#x27;1&#x27; 的个数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span> * (<span class="built_in">len</span>(binary) - <span class="number">1</span> - cnt1) + <span class="string">&#x27;0&#x27;</span> + <span class="string">&#x27;1&#x27;</span> * cnt1</span><br></pre></td></tr></table></figure>
<h3 id="11号-1766-互质树">11号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/tree-of-coprimes/">1766. 互质树</a></h3>
<p>给你一个 <code>n</code> 个节点的树（也就是一个无环连通无向图），节点编号从 <code>0</code> 到 <code>n - 1</code> ，且恰好有 <code>n - 1</code> 条边，每个节点有一个值。树的 <strong>根节点</strong> 为 0 号点。</p>
<p>给你一个整数数组 <code>nums</code> 和一个二维数组 <code>edges</code> 来表示这棵树。<code>nums[i]</code> 表示第 <code>i</code> 个点的值，<code>edges[j] = [uj, vj]</code> 表示节点 <code>uj</code> 和节点 <code>vj</code> 在树中有一条边。</p>
<p>当 <code>gcd(x, y) == 1</code> ，我们称两个数 <code>x</code> 和 <code>y</code> 是 <strong>互质的</strong> ，其中 <code>gcd(x, y)</code> 是 <code>x</code> 和 <code>y</code> 的 <strong>最大公约数</strong> 。</p>
<p>从节点 <code>i</code> 到 <strong>根</strong> 最短路径上的点都是节点 <code>i</code> 的祖先节点。一个节点 <strong>不是</strong> 它自己的祖先节点。</p>
<p>请你返回一个大小为 <code>n</code> 的数组 <code>ans</code> ，其中 <code>ans[i]</code>是离节点 <code>i</code> 最近的祖先节点且满足 <code>nums[i]</code> 和 <code>nums[ans[i]]</code> 是 <strong>互质的</strong> ，如果不存在这样的祖先节点，<code>ans[i]</code> 为 <code>-1</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getCoprimes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], edges: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        gcds = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">51</span>)] <span class="comment">#注意题目，nums[i] &lt;= 50</span></span><br><span class="line">        tmp = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">51</span>)]</span><br><span class="line">        ans = [-<span class="number">1</span>] * n</span><br><span class="line">        dep = [-<span class="number">1</span>] * n </span><br><span class="line">        g = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x: <span class="built_in">int</span>, depth: <span class="built_in">int</span></span>):</span><br><span class="line">            dep[x] = depth</span><br><span class="line">            <span class="keyword">for</span> val <span class="keyword">in</span> gcds[nums[x]]:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> tmp[val]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                las = tmp[val][-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> ans[x] == -<span class="number">1</span> <span class="keyword">or</span> dep[las] &gt; dep[ans[x]]:</span><br><span class="line">                    ans[x] = las</span><br><span class="line">            tmp[nums[x]].append(x)</span><br><span class="line">            <span class="keyword">for</span> val <span class="keyword">in</span> g[x]:</span><br><span class="line">                <span class="keyword">if</span> dep[val] == -<span class="number">1</span>: <span class="comment"># 被访问过的点dep不为-1</span></span><br><span class="line">                    dfs(val, depth + <span class="number">1</span>)</span><br><span class="line">            tmp[nums[x]].pop()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">51</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">51</span>):</span><br><span class="line">                <span class="keyword">if</span> math.gcd(i, j) == <span class="number">1</span>:</span><br><span class="line">                    gcds[i].append(j)</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> edges:</span><br><span class="line">            g[x].append(y)</span><br><span class="line">            g[y].append(x)</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="12号-2923-找到冠军-I">12号__<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-champion-i/">2923. 找到冠军 I</a></h3>
<p>一场比赛中共有 <code>n</code> 支队伍，按从 <code>0</code> 到 <code>n - 1</code> 编号。</p>
<p>给你一个下标从 <strong>0</strong> 开始、大小为 <code>n * n</code> 的二维布尔矩阵 <code>grid</code> 。对于满足 <code>0 &lt;= i, j &lt;= n - 1</code> 且 <code>i != j</code> 的所有 <code>i, j</code> ：如果 <code>grid[i][j] == 1</code>，那么 <code>i</code> 队比 <code>j</code> 队 <strong>强</strong> ；否则，<code>j</code> 队比 <code>i</code> 队 <strong>强</strong> 。</p>
<p>在这场比赛中，如果不存在某支强于 <code>a</code> 队的队伍，则认为 <code>a</code> 队将会是 <strong>冠军</strong> 。</p>
<p>返回这场比赛中将会成为冠军的队伍。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findChampion</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">for</span> j, col <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(*grid)):</span><br><span class="line">            <span class="keyword">if</span> <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> col:</span><br><span class="line">                <span class="keyword">return</span> j</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打擂台</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findChampion</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, row <span class="keyword">in</span> <span class="built_in">enumerate</span>(grid):</span><br><span class="line">            <span class="keyword">if</span> row[ans]:</span><br><span class="line">                ans = i</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="13号-2924-找到冠军-II">13号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-champion-ii/">2924. 找到冠军 II</a></h3>
<p>一场比赛中共有 <code>n</code> 支队伍，按从 <code>0</code> 到 <code>n - 1</code> 编号。每支队伍也是 <strong>有向无环图（DAG）</strong> 上的一个节点。</p>
<p>给你一个整数 <code>n</code> 和一个下标从 <strong>0</strong> 开始、长度为 <code>m</code> 的二维整数数组 <code>edges</code> 表示这个有向无环图，其中 <code>edges[i] = [ui, vi]</code> 表示图中存在一条从 <code>ui</code> 队到 <code>vi</code> 队的有向边。</p>
<p>从 <code>a</code> 队到 <code>b</code> 队的有向边意味着 <code>a</code> 队比 <code>b</code> 队 <strong>强</strong> ，也就是 <code>b</code> 队比 <code>a</code> 队 <strong>弱</strong> 。</p>
<p>在这场比赛中，如果不存在某支强于 <code>a</code> 队的队伍，则认为 <code>a</code> 队将会是 <strong>冠军</strong> 。</p>
<p>如果这场比赛存在 <strong>唯一</strong> 一个冠军，则返回将会成为冠军的队伍。否则，返回 <code>-1</code> <em>。</em></p>
<p><strong>注意</strong></p>
<ul>
<li><strong>环</strong> 是形如 <code>a1, a2, ..., an, an+1</code> 的一个序列，且满足：节点 <code>a1</code> 与节点 <code>an+1</code> 是同一个节点；节点 <code>a1, a2, ..., an</code> 互不相同；对于范围 <code>[1, n]</code> 中的每个 <code>i</code> ，均存在一条从节点 <code>ai</code> 到节点 <code>ai+1</code> 的有向边。</li>
<li><strong>有向无环图</strong> 是不存在任何环的有向图。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#dfs</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findChampion</span>(<span class="params">self, n: <span class="built_in">int</span>, edges: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        g = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> edges:</span><br><span class="line">            g[y].append(x)</span><br><span class="line">        visit = [<span class="literal">False</span>] * n</span><br><span class="line">        ans = inf</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> g[x]:</span><br><span class="line">                <span class="keyword">nonlocal</span> ans</span><br><span class="line">                <span class="keyword">if</span> ans == inf <span class="keyword">or</span> ans == x: ans = x</span><br><span class="line">                <span class="keyword">else</span>: ans = -<span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            visit[x] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> g[x]:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> visit[y]: dfs(y)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n): dfs(x)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#直接遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findChampion</span>(<span class="params">self, n: <span class="built_in">int</span>, edges: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        degree = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> edges:</span><br><span class="line">            degree[y] += <span class="number">1</span></span><br><span class="line">        champion = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i, d <span class="keyword">in</span> <span class="built_in">enumerate</span>(degree):</span><br><span class="line">            <span class="keyword">if</span> d == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> champion == -<span class="number">1</span>:</span><br><span class="line">                    champion = i</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> champion</span><br></pre></td></tr></table></figure>
<h3 id="14号-705-设计哈希集合"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-hashset/">14号_705. 设计哈希集合</a></h3>
<p>不使用任何内建的哈希表库设计一个哈希集合（HashSet）。</p>
<p>实现 <code>MyHashSet</code> 类：</p>
<ul>
<li><code>void add(key)</code> 向哈希集合中插入值 <code>key</code> 。</li>
<li><code>bool contains(key)</code> 返回哈希集合中是否存在这个值 <code>key</code> 。</li>
<li><code>void remove(key)</code> 将给定值 <code>key</code> 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#集合（实际就是哈希表）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyHashSet</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.mp = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.mp.add(key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.contains(key):</span><br><span class="line">            <span class="variable language_">self</span>.mp.remove(key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">contains</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> key <span class="keyword">in</span> <span class="variable language_">self</span>.mp <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#数组</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyHashSet</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.data = [<span class="literal">False</span>] * <span class="number">1000001</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.data[key] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.data[key] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">contains</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.data[key]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#数组+链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyHashSet</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.size = <span class="number">1000</span></span><br><span class="line">        <span class="variable language_">self</span>.data = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.size)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.contains(key):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        idx = <span class="variable language_">self</span>.<span class="built_in">hash</span>(key)</span><br><span class="line">        <span class="variable language_">self</span>.data[idx].append(key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.contains(key):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        idx = <span class="variable language_">self</span>.<span class="built_in">hash</span>(key)</span><br><span class="line">        <span class="variable language_">self</span>.data[idx].remove(key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">contains</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        idx = <span class="variable language_">self</span>.<span class="built_in">hash</span>(key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">any</span>(v == key <span class="keyword">for</span> v <span class="keyword">in</span> <span class="variable language_">self</span>.data[idx])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash</span>(<span class="params">self, key</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> key % <span class="variable language_">self</span>.size</span><br></pre></td></tr></table></figure>
<h3 id="15号-706-设计哈希映射">15号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-hashmap/">706. 设计哈希映射</a></h3>
<p>不使用任何内建的哈希表库设计一个哈希映射（HashMap）。</p>
<p>实现 <code>MyHashMap</code> 类：</p>
<ul>
<li><code>MyHashMap()</code> 用空映射初始化对象</li>
<li><code>void put(int key, int value)</code> 向 HashMap 插入一个键值对 <code>(key, value)</code> 。如果 <code>key</code> 已经存在于映射中，则更新其对应的值 <code>value</code> 。</li>
<li><code>int get(int key)</code> 返回特定的 <code>key</code> 所映射的 <code>value</code> ；如果映射中不包含 <code>key</code> 的映射，返回 <code>-1</code> 。</li>
<li><code>void remove(key)</code> 如果映射中存在 <code>key</code> 的映射，则移除 <code>key</code> 和它所对应的 <code>value</code> 。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyHashMap</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.mp = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.mp[key] = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.mp[key] <span class="keyword">if</span> key <span class="keyword">in</span> <span class="variable language_">self</span>.mp <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> <span class="variable language_">self</span>.mp: <span class="keyword">del</span> <span class="variable language_">self</span>.mp[key]</span><br></pre></td></tr></table></figure>
<h3 id="16号-924-尽量减少恶意软件的传播">16号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimize-malware-spread/">924. 尽量减少恶意软件的传播</a></h3>
<p>给出了一个由 <code>n</code> 个节点组成的网络，用 <code>n × n</code> 个邻接矩阵图 <code>graph</code> 表示。在节点网络中，当 <code>graph[i][j] = 1</code> 时，表示节点 <code>i</code> 能够直接连接到另一个节点 <code>j</code>。</p>
<p>一些节点 <code>initial</code> 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。</p>
<p>假设 <code>M(initial)</code> 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。</p>
<p>如果从 <code>initial</code> 中<strong>移除某一节点</strong>能够最小化 <code>M(initial)</code>， 返回该节点。如果有多个节点满足条件，就返回<strong>索引最小</strong>的节点。</p>
<p>请注意，如果某个节点已从受感染节点的列表 <code>initial</code> 中删除，它以后仍有可能因恶意软件传播而受到感染。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minMalwareSpread</span>(<span class="params">self, graph: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], initial: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        st = <span class="built_in">set</span>(initial)</span><br><span class="line">        vis = [<span class="literal">False</span>] * <span class="built_in">len</span>(graph)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">            vis[x] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">nonlocal</span> node_id, size</span><br><span class="line">            size += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 按照状态机更新 node_id</span></span><br><span class="line">            <span class="keyword">if</span> node_id != -<span class="number">2</span> <span class="keyword">and</span> x <span class="keyword">in</span> st:</span><br><span class="line">                node_id = x <span class="keyword">if</span> node_id == -<span class="number">1</span> <span class="keyword">else</span> -<span class="number">2</span></span><br><span class="line">            <span class="keyword">for</span> y, conn <span class="keyword">in</span> <span class="built_in">enumerate</span>(graph[x]):</span><br><span class="line">                <span class="keyword">if</span> conn <span class="keyword">and</span> <span class="keyword">not</span> vis[y]:</span><br><span class="line">                    dfs(y)</span><br><span class="line"></span><br><span class="line">        ans = -<span class="number">1</span></span><br><span class="line">        max_size = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> initial:</span><br><span class="line">            <span class="keyword">if</span> vis[x]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            node_id = -<span class="number">1</span></span><br><span class="line">            size = <span class="number">0</span></span><br><span class="line">            dfs(x)</span><br><span class="line">            <span class="keyword">if</span> node_id &gt;= <span class="number">0</span> <span class="keyword">and</span> (size &gt; max_size <span class="keyword">or</span> size == max_size <span class="keyword">and</span> node_id &lt; ans):</span><br><span class="line">                ans = node_id</span><br><span class="line">                max_size = size</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(initial) <span class="keyword">if</span> ans &lt; <span class="number">0</span> <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="17号-928-尽量减少恶意软件的传播-II">17号__<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimize-malware-spread-ii/">928. 尽量减少恶意软件的传播 II</a></h3>
<p>给定一个由 <code>n</code> 个节点组成的网络，用 <code>n x n</code> 个邻接矩阵 <code>graph</code> 表示。在节点网络中，只有当 <code>graph[i][j] = 1</code> 时，节点 <code>i</code> 能够直接连接到另一个节点 <code>j</code>。</p>
<p>一些节点 <code>initial</code> 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。</p>
<p>假设 <code>M(initial)</code> 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。</p>
<p>我们可以从 <code>initial</code> 中<strong>删除一个节点</strong>，<strong>并完全移除该节点以及从该节点到任何其他节点的任何连接。</strong></p>
<p>请返回移除后能够使 <code>M(initial)</code> 最小化的节点。如果有多个节点满足条件，返回索引 <strong>最小的节点</strong> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minMalwareSpread</span>(<span class="params">self, graph: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], initial: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        st = <span class="built_in">set</span>(initial)</span><br><span class="line">        vis = [<span class="literal">False</span>] * <span class="built_in">len</span>(graph)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">            vis[x] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">nonlocal</span> node_id, size</span><br><span class="line">            size += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> y, conn <span class="keyword">in</span> <span class="built_in">enumerate</span>(graph[x]):</span><br><span class="line">                <span class="keyword">if</span> conn == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> y <span class="keyword">in</span> st:</span><br><span class="line">                    <span class="comment"># 按照 924 题的状态机更新 node_id</span></span><br><span class="line">                    <span class="comment"># 注意避免重复统计，例如上图中的 0 有两条不同路径可以遇到 1</span></span><br><span class="line">                    <span class="keyword">if</span> node_id != -<span class="number">2</span> <span class="keyword">and</span> node_id != y:</span><br><span class="line">                        node_id = y <span class="keyword">if</span> node_id == -<span class="number">1</span> <span class="keyword">else</span> -<span class="number">2</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="keyword">not</span> vis[y]:</span><br><span class="line">                    dfs(y)</span><br><span class="line"></span><br><span class="line">        cnt = Counter()</span><br><span class="line">        <span class="keyword">for</span> i, seen <span class="keyword">in</span> <span class="built_in">enumerate</span>(vis):</span><br><span class="line">            <span class="keyword">if</span> seen <span class="keyword">or</span> i <span class="keyword">in</span> st:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            node_id = -<span class="number">1</span></span><br><span class="line">            size = <span class="number">0</span></span><br><span class="line">            dfs(i)</span><br><span class="line">            <span class="keyword">if</span> node_id &gt;= <span class="number">0</span>:  <span class="comment"># 只找到一个在 initial 中的节点</span></span><br><span class="line">                <span class="comment"># 删除节点 node_id 可以让 size 个点不被感染</span></span><br><span class="line">                cnt[node_id] += size</span><br><span class="line"></span><br><span class="line">        <span class="comment"># size 取反计算最大值，相同最大值取 node_id 最小值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>((-size, node_id) <span class="keyword">for</span> node_id, size <span class="keyword">in</span> cnt.items())[<span class="number">1</span>] <span class="keyword">if</span> cnt <span class="keyword">else</span> <span class="built_in">min</span>(initial)</span><br></pre></td></tr></table></figure>
<h3 id="18号-2007-从双倍数组中还原原数组">18号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-original-array-from-doubled-array/">2007. 从双倍数组中还原原数组</a></h3>
<p>一个整数数组 <code>original</code> 可以转变成一个 <strong>双倍</strong> 数组 <code>changed</code> ，转变方式为将 <code>original</code> 中每个元素 <strong>值乘以 2</strong> 加入数组中，然后将所有元素 <strong>随机打乱</strong> 。</p>
<p>给你一个数组 <code>changed</code> ，如果 <code>change</code> 是 <strong>双倍</strong> 数组，那么请你返回 <code>original</code>数组，否则请返回空数组。<code>original</code> 的元素可以以 <strong>任意</strong> 顺序返回。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findOriginalArray</span>(<span class="params">self, changed: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        changed.sort()</span><br><span class="line">        ans = []</span><br><span class="line">        cnt = Counter()</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> changed:</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> cnt:  <span class="comment"># x 不是双倍后的元素</span></span><br><span class="line">                cnt[x * <span class="number">2</span>] += <span class="number">1</span>  <span class="comment"># 标记一个双倍元素</span></span><br><span class="line">                ans.append(x)</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># x 是双倍后的元素</span></span><br><span class="line">                cnt[x] -= <span class="number">1</span>  <span class="comment"># 清除一个标记</span></span><br><span class="line">                <span class="keyword">if</span> cnt[x] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> cnt[x]</span><br><span class="line">        <span class="comment"># 只有所有双倍标记都被清除掉，才能说明 changed 是一个双倍数组</span></span><br><span class="line">        <span class="keyword">return</span> [] <span class="keyword">if</span> cnt <span class="keyword">else</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#排序+队列</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findOriginalArray</span>(<span class="params">self, changed: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        changed.sort()</span><br><span class="line">        ans = []</span><br><span class="line">        q = deque()</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> changed:</span><br><span class="line">            <span class="keyword">if</span> q:</span><br><span class="line">                <span class="keyword">if</span> q[<span class="number">0</span>] &lt; x:  <span class="comment"># 无法配对</span></span><br><span class="line">                    <span class="keyword">return</span> []</span><br><span class="line">                <span class="keyword">if</span> q[<span class="number">0</span>] == x:  <span class="comment"># 配对成功</span></span><br><span class="line">                    q.popleft()  <span class="comment"># 清除一个标记</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            ans.append(x)</span><br><span class="line">            q.append(x * <span class="number">2</span>)  <span class="comment"># 添加双倍标记</span></span><br><span class="line">        <span class="comment"># 只有所有双倍标记都被清除掉，才能说明 changed 是一个双倍数组</span></span><br><span class="line">        <span class="keyword">return</span> [] <span class="keyword">if</span> q <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#排序+双指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findOriginalArray</span>(<span class="params">self, changed: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(changed)</span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span>: <span class="keyword">return</span> []</span><br><span class="line">        changed.sort()</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            <span class="keyword">if</span> changed[i] == <span class="number">0</span>: i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2</span>: <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">else</span>: res += [<span class="number">0</span>] * (i//<span class="number">2</span>)</span><br><span class="line">        j = i + <span class="number">1</span></span><br><span class="line">        double = [<span class="literal">False</span>] * n</span><br><span class="line">        <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> j &lt; n:</span><br><span class="line">            <span class="keyword">while</span> j &lt; n <span class="keyword">and</span> changed[j] != <span class="number">2</span> * changed[i]: j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j == n: <span class="keyword">break</span></span><br><span class="line">            double[j] = <span class="literal">True</span></span><br><span class="line">            res.append(changed[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> double[i]: i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> <span class="built_in">len</span>(res) == n // <span class="number">2</span> <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#消消乐</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findOriginalArray</span>(<span class="params">self, changed: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        cnt = Counter(changed)</span><br><span class="line">        <span class="comment"># 单独处理 0</span></span><br><span class="line">        cnt0 = cnt.pop(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> cnt0 % <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = [<span class="number">0</span>] * (cnt0 // <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> cnt:</span><br><span class="line">            <span class="comment"># 如果 x/2 在 cnt 中，则跳过</span></span><br><span class="line">            <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> x // <span class="number">2</span> <span class="keyword">in</span> cnt:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 把 x, 2x, 4x, 8x, ... 全部配对</span></span><br><span class="line">            <span class="keyword">while</span> x <span class="keyword">in</span> cnt:</span><br><span class="line">                <span class="comment"># 每次循环，把 cnt_x 个 x 和 cnt_x 个 2x 配对</span></span><br><span class="line">                cnt_x = cnt[x]</span><br><span class="line">                <span class="comment"># 无法配对，至少要有 cnt_x 个 2x</span></span><br><span class="line">                <span class="keyword">if</span> cnt_x &gt; cnt[x * <span class="number">2</span>]:</span><br><span class="line">                    <span class="keyword">return</span> []</span><br><span class="line">                ans.extend([x] * cnt_x)</span><br><span class="line">                <span class="keyword">if</span> cnt_x &lt; cnt[x * <span class="number">2</span>]:</span><br><span class="line">                    <span class="comment"># 还剩下一些 2x</span></span><br><span class="line">                    cnt[x * <span class="number">2</span>] -= cnt_x</span><br><span class="line">                    x *= <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    x *= <span class="number">4</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="19号-1883-准时抵达会议现场的最小跳过休息次数">19号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-skips-to-arrive-at-meeting-on-time/">1883. 准时抵达会议现场的最小跳过休息次数</a></h3>
<p>给你一个整数 <code>hoursBefore</code> ，表示你要前往会议所剩下的可用小时数。要想成功抵达会议现场，你必须途经 <code>n</code> 条道路。道路的长度用一个长度为 <code>n</code> 的整数数组 <code>dist</code> 表示，其中 <code>dist[i]</code> 表示第 <code>i</code> 条道路的长度（单位：<strong>千米</strong>）。另给你一个整数 <code>speed</code> ，表示你在道路上前进的速度（单位：<strong>千米每小时</strong>）。</p>
<p>当你通过第 <code>i</code> 条路之后，就必须休息并等待，直到 <strong>下一个整数小时</strong> 才能开始继续通过下一条道路。注意：你不需要在通过最后一条道路后休息，因为那时你已经抵达会议现场。</p>
<ul>
<li>例如，如果你通过一条道路用去 <code>1.4</code> 小时，那你必须停下来等待，到 <code>2</code> 小时才可以继续通过下一条道路。如果通过一条道路恰好用去 <code>2</code> 小时，就无需等待，可以直接继续。</li>
</ul>
<p>然而，为了能准时到达，你可以选择 <strong>跳过</strong> 一些路的休息时间，这意味着你不必等待下一个整数小时。注意，这意味着与不跳过任何休息时间相比，你可能在不同时刻到达接下来的道路。</p>
<ul>
<li>例如，假设通过第 <code>1</code> 条道路用去 <code>1.4</code> 小时，且通过第 <code>2</code> 条道路用去 <code>0.6</code> 小时。跳过第 <code>1</code> 条道路的休息时间意味着你将会在恰好 <code>2</code> 小时完成通过第 <code>2</code> 条道路，且你能够立即开始通过第 <code>3</code> 条道路。</li>
</ul>
<p>返回准时抵达会议现场所需要的 <strong>最小跳过次数</strong> ，如果 <strong>无法准时参会</strong> ，返回 <code>-1</code> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSkips</span>(<span class="params">self, dist: <span class="type">List</span>[<span class="built_in">int</span>], speed: <span class="built_in">int</span>, hoursBefore: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 可忽略误差</span></span><br><span class="line">        EPS = <span class="number">1e-7</span>       </span><br><span class="line">        n = <span class="built_in">len</span>(dist)</span><br><span class="line">        f = [[<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0.</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j != i:</span><br><span class="line">                    f[i][j] = <span class="built_in">min</span>(f[i][j], ceil(f[i - <span class="number">1</span>][j] + dist[i - <span class="number">1</span>] / speed - EPS))</span><br><span class="line">                <span class="keyword">if</span> j != <span class="number">0</span>:</span><br><span class="line">                    f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + dist[i - <span class="number">1</span>] / speed)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> f[n][j] &lt; hoursBefore + EPS:</span><br><span class="line">                <span class="keyword">return</span> j</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="20号-39-组合总和">20号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h3>
<p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p>
<p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p>
<p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params"></span></span><br><span class="line"><span class="params">            state: <span class="built_in">list</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span>, choices: <span class="built_in">list</span>[<span class="built_in">int</span>], start: <span class="built_in">int</span>, res: <span class="built_in">list</span>[<span class="built_in">list</span>[<span class="built_in">int</span>]]</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;回溯算法：子集和 I&quot;&quot;&quot;</span></span><br><span class="line">            <span class="comment"># 子集和等于 target 时，记录解</span></span><br><span class="line">            <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">                res.append(<span class="built_in">list</span>(state))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 遍历所有选择</span></span><br><span class="line">            <span class="comment"># 剪枝二：从 start 开始遍历，避免生成重复子集</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(choices)):</span><br><span class="line">                <span class="comment"># 剪枝一：若子集和超过 target ，则直接结束循环</span></span><br><span class="line">                <span class="comment"># 这是因为数组已排序，后边元素更大，子集和一定超过 target</span></span><br><span class="line">                <span class="keyword">if</span> target - choices[i] &lt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># 尝试：做出选择，更新 target, start</span></span><br><span class="line">                state.append(choices[i])</span><br><span class="line">                <span class="comment"># 进行下一轮选择</span></span><br><span class="line">                backtrack(state, target - choices[i], choices, i, res)</span><br><span class="line">                <span class="comment"># 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">                state.pop()</span><br><span class="line"></span><br><span class="line">        state = []  <span class="comment"># 状态（子集）</span></span><br><span class="line">        candidates.sort()  <span class="comment"># 对 candidates 进行排序</span></span><br><span class="line">        start = <span class="number">0</span>  <span class="comment"># 遍历起始点</span></span><br><span class="line">        res = []  <span class="comment"># 结果列表（子集列表）</span></span><br><span class="line">        backtrack(state, target, candidates, start, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="21号-216-组合总和-III">21号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></h3>
<p>找出所有相加之和为 <code>n</code> 的 <code>k</code> 个数的组合，且满足下列条件：</p>
<ul>
<li>只使用数字1到9</li>
<li>每个数字 <strong>最多使用一次</strong></li>
</ul>
<p>返回 <em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum3</span>(<span class="params">self, k: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        ans = []</span><br><span class="line">        path = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i: <span class="built_in">int</span>, t: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">            d = k - <span class="built_in">len</span>(path)  <span class="comment"># 还要选 d 个数</span></span><br><span class="line">            <span class="keyword">if</span> t &lt; <span class="number">0</span> <span class="keyword">or</span> t &gt; (i * <span class="number">2</span> - d + <span class="number">1</span>) * d // <span class="number">2</span>:  <span class="comment"># 剪枝</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> d == <span class="number">0</span>:  <span class="comment"># 找到一个合法组合</span></span><br><span class="line">                ans.append(path.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, d - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                path.append(j)</span><br><span class="line">                dfs(j - <span class="number">1</span>, t - j)</span><br><span class="line">                path.pop()</span><br><span class="line">        dfs(<span class="number">9</span>, n)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="22号-377-组合总和-Ⅳ">22号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></h3>
<p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p>
<p>题目数据保证答案符合 32 位整数范围。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum4</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        dp = [<span class="number">0</span>] * (target+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,target+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt;= i:</span><br><span class="line">                    dp[i] += dp[i-nums[j]]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum4</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"><span class="meta">        @cache  </span><span class="comment"># 缓存装饰器，避免重复计算 dfs 的结果</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:  <span class="comment"># 爬完了</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sum</span>(dfs(i - x) <span class="keyword">for</span> x <span class="keyword">in</span> nums <span class="keyword">if</span> x &lt;= i)  <span class="comment"># 枚举所有可以爬的台阶数</span></span><br><span class="line">        <span class="keyword">return</span> dfs(target)</span><br></pre></td></tr></table></figure>
<h3 id="23-1052-爱生气的书店老板">23_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/grumpy-bookstore-owner/">1052. 爱生气的书店老板</a></h3>
<p>有一个书店老板，他的书店开了 <code>n</code> 分钟。每分钟都有一些顾客进入这家商店。给定一个长度为 <code>n</code> 的整数数组 <code>customers</code> ，其中 <code>customers[i]</code> 是在第 <code>i</code> 分钟开始时进入商店的顾客数量，所有这些顾客在第 <code>i</code> 分钟结束后离开。</p>
<p>在某些时候，书店老板会生气。 如果书店老板在第 <code>i</code> 分钟生气，那么 <code>grumpy[i] = 1</code>，否则 <code>grumpy[i] = 0</code>。</p>
<p>当书店老板生气时，那一分钟的顾客就会不满意，若老板不生气则顾客是满意的。</p>
<p>书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 <code>minutes</code> 分钟不生气，但却只能使用一次。</p>
<p>请你返回 <em>这一天营业下来，最多有多少客户能够感到满意</em> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSatisfied</span>(<span class="params">self, customers: <span class="type">List</span>[<span class="built_in">int</span>], grumpy: <span class="type">List</span>[<span class="built_in">int</span>], minutes: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(customers)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> grumpy[i]: grumpy[i] = customers[i]</span><br><span class="line">            <span class="keyword">else</span>: res += customers[i]</span><br><span class="line">        mx = total = <span class="built_in">sum</span>(grumpy[:minutes])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n-minutes+<span class="number">1</span>):</span><br><span class="line">            total = total + grumpy[i+minutes-<span class="number">1</span>] - grumpy[i-<span class="number">1</span>]</span><br><span class="line">            mx = <span class="built_in">max</span>(mx,total)</span><br><span class="line">        <span class="keyword">return</span> res + mx</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSatisfied</span>(<span class="params">self, customers: <span class="type">List</span>[<span class="built_in">int</span>], grumpy: <span class="type">List</span>[<span class="built_in">int</span>], minutes: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(customers)</span><br><span class="line">        total = <span class="built_in">sum</span>(c <span class="keyword">for</span> c, g <span class="keyword">in</span> <span class="built_in">zip</span>(customers, grumpy) <span class="keyword">if</span> g == <span class="number">0</span>)</span><br><span class="line">        maxIncrease = increase = <span class="built_in">sum</span>(c * g <span class="keyword">for</span> c, g <span class="keyword">in</span> <span class="built_in">zip</span>(customers[:minutes], grumpy[:minutes]))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(minutes, n):</span><br><span class="line">            increase += customers[i] * grumpy[i] - customers[i - minutes] * grumpy[i - minutes]</span><br><span class="line">            maxIncrease = <span class="built_in">max</span>(maxIncrease, increase)</span><br><span class="line">        <span class="keyword">return</span> total + maxIncrease</span><br></pre></td></tr></table></figure>
<h3 id="24号-2385-感染二叉树需要的总时间">24号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/amount-of-time-for-binary-tree-to-be-infected/">2385. 感染二叉树需要的总时间</a></h3>
<p>给你一棵二叉树的根节点 <code>root</code> ，二叉树中节点的值 <strong>互不相同</strong> 。另给你一个整数 <code>start</code> 。在第 <code>0</code> 分钟，<strong>感染</strong> 将会从值为 <code>start</code> 的节点开始爆发。</p>
<p>每分钟，如果节点满足以下全部条件，就会被感染：</p>
<ul>
<li>节点此前还没有感染。</li>
<li>节点与一个已感染节点相邻。</li>
</ul>
<p>返回感染整棵树需要的分钟数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将树改成无向图</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">amountOfTime</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], start: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        fa = &#123;&#125;</span><br><span class="line">        start_node = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node: <span class="type">Optional</span>[TreeNode], from_: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            fa[node] = from_  <span class="comment"># 记录每个节点的父节点</span></span><br><span class="line">            <span class="keyword">if</span> node.val == start:  <span class="comment"># 找到 start</span></span><br><span class="line">                <span class="keyword">nonlocal</span> start_node</span><br><span class="line">                start_node = node</span><br><span class="line">            dfs(node.left, node)</span><br><span class="line">            dfs(node.right, node)</span><br><span class="line">        dfs(root, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">node: <span class="type">Optional</span>[TreeNode], from_: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>  <span class="comment"># 注意这里是 -1，因为 start 的深度为 0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(maxDepth(x, node) <span class="keyword">for</span> x <span class="keyword">in</span> (node.left, node.right, fa[node]) <span class="keyword">if</span> x != from_) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> maxDepth(start_node, start_node)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#分为叶部和父部两块</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">amountOfTime</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], start: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node: <span class="type">Optional</span>[TreeNode]</span>) -&gt; (<span class="built_in">int</span>, <span class="built_in">bool</span>):</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">False</span></span><br><span class="line">            l_len, l_found = dfs(node.left)</span><br><span class="line">            r_len, r_found = dfs(node.right)</span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            <span class="keyword">if</span> node.val == start:</span><br><span class="line">                <span class="comment"># 计算子树 start 的最大深度</span></span><br><span class="line">                <span class="comment"># 注意这里和方法一的区别，max 后面没有 +1，所以算出的也是最大深度</span></span><br><span class="line">                ans = <span class="built_in">max</span>(l_len, r_len)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>, <span class="literal">True</span>  <span class="comment"># 找到了 start</span></span><br><span class="line">            <span class="keyword">if</span> l_found <span class="keyword">or</span> r_found:</span><br><span class="line">                <span class="comment"># 只有在左子树或右子树包含 start 时，才能更新答案</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, l_len + r_len)  <span class="comment"># 两条链拼成直径</span></span><br><span class="line">                <span class="comment"># 保证 start 是直径端点</span></span><br><span class="line">                <span class="keyword">return</span> (l_len <span class="keyword">if</span> l_found <span class="keyword">else</span> r_len) + <span class="number">1</span>, <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(l_len, r_len) + <span class="number">1</span>, <span class="literal">False</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="25号-2739-总行驶距离">25号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/total-distance-traveled/">2739. 总行驶距离</a></h3>
<p>卡车有两个油箱。给你两个整数，<code>mainTank</code> 表示主油箱中的燃料（以升为单位），<code>additionalTank</code> 表示副油箱中的燃料（以升为单位）。</p>
<p>该卡车每耗费 <code>1</code> 升燃料都可以行驶 <code>10</code> km。每当主油箱使用了 <code>5</code> 升燃料时，如果副油箱至少有 <code>1</code> 升燃料，则会将 <code>1</code> 升燃料从副油箱转移到主油箱。</p>
<p>返回卡车可以行驶的最大距离。</p>
<p>注意：从副油箱向主油箱注入燃料不是连续行为。这一事件会在每消耗 <code>5</code> 升燃料时突然且立即发生。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">distanceTraveled</span>(<span class="params">self, mainTank: <span class="built_in">int</span>, additionalTank: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> mainTank &gt;= <span class="number">5</span>:</span><br><span class="line">            mainTank -= <span class="number">5</span></span><br><span class="line">            res += <span class="number">50</span></span><br><span class="line">            <span class="keyword">if</span> additionalTank &gt;= <span class="number">1</span>:</span><br><span class="line">                mainTank += <span class="number">1</span></span><br><span class="line">                additionalTank -= <span class="number">1</span></span><br><span class="line">        res += mainTank * <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> res  </span><br></pre></td></tr></table></figure>
<h3 id="26号-1146-快照数组">26号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/snapshot-array/">1146. 快照数组</a></h3>
<p>实现支持下列接口的「快照数组」- SnapshotArray：</p>
<ul>
<li><code>SnapshotArray(int length)</code> - 初始化一个与指定长度相等的 类数组 的数据结构。<strong>初始时，每个元素都等于</strong> <strong>0</strong>。</li>
<li><code>void set(index, val)</code> - 会将指定索引 <code>index</code> 处的元素设置为 <code>val</code>。</li>
<li><code>int snap()</code> - 获取该数组的快照，并返回快照的编号 <code>snap_id</code>（快照号是调用 <code>snap()</code> 的总次数减去 <code>1</code>）。</li>
<li><code>int get(index, snap_id)</code> - 根据指定的 <code>snap_id</code> 选择快照，并返回该快照指定索引 <code>index</code> 的值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SnapshotArray</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, _: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.cur_snap_id = <span class="number">0</span></span><br><span class="line">        <span class="variable language_">self</span>.history = defaultdict(<span class="built_in">list</span>)  <span class="comment"># 每个 index 的历史修改记录</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set</span>(<span class="params">self, index: <span class="built_in">int</span>, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.history[index].append((<span class="variable language_">self</span>.cur_snap_id, val))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">snap</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="variable language_">self</span>.cur_snap_id += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.cur_snap_id - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, index: <span class="built_in">int</span>, snap_id: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 找快照编号 &lt;= snap_id 的最后一次修改记录</span></span><br><span class="line">        <span class="comment"># 等价于找快照编号 &gt;= snap_id+1 的第一个修改记录，它的上一个就是答案</span></span><br><span class="line">        j = bisect_left(<span class="variable language_">self</span>.history[index], (snap_id + <span class="number">1</span>,)) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.history[index][j][<span class="number">1</span>] <span class="keyword">if</span> j &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>27号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-width-of-columns-of-a-grid/">2639. 查询网格图中每一列的宽度</a></p>
<p>给你一个下标从 <strong>0</strong> 开始的 <code>m x n</code> 整数矩阵 <code>grid</code> 。矩阵中某一列的宽度是这一列数字的最大 <strong>字符串长度</strong> 。</p>
<ul>
<li>比方说，如果 <code>grid = [[-10], [3], [12]]</code> ，那么唯一一列的宽度是 <code>3</code> ，因为 <code>-10</code> 的字符串长度为 <code>3</code> 。</li>
</ul>
<p>请你返回一个大小为 <code>n</code> 的整数数组 <code>ans</code> ，其中 <code>ans[i]</code> 是第 <code>i</code> 列的宽度。</p>
<p>一个有 <code>len</code> 个数位的整数 <code>x</code> ，如果是非负数，那么 <strong>字符串****长度</strong> 为 <code>len</code> ，否则为 <code>len + 1</code> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findColumnWidth</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        m = <span class="built_in">len</span>(grid)</span><br><span class="line">        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            max_len = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m): max_len = <span class="built_in">max</span>(max_len,<span class="built_in">len</span>(<span class="built_in">str</span>(grid[i][j])))</span><br><span class="line">            res.append (max_len)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="28号-1017-负二进制转换">28号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-to-base-2/">1017. 负二进制转换</a></h3>
<p>给你一个整数 <code>n</code> ，以二进制字符串的形式返回该整数的 **负二进制（<code>base -2</code>）**表示。</p>
<p>**注意，**除非字符串就是 <code>&quot;0&quot;</code>，否则返回的字符串中不能含有前导零。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">baseNeg2</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span></span><br><span class="line"></span><br><span class="line">        bits = [<span class="number">0</span>] * <span class="number">32</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span>:</span><br><span class="line">                bits[i] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i &amp; <span class="number">1</span>:</span><br><span class="line">                    bits[i + <span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            val = carry + bits[i]</span><br><span class="line">            bits[i] = val &amp; <span class="number">1</span></span><br><span class="line">            carry = (val - bits[i]) // -<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        pos = <span class="number">31</span></span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> pos &gt;= <span class="number">0</span> <span class="keyword">and</span> bits[pos] == <span class="number">0</span>:</span><br><span class="line">            pos -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> pos &gt;= <span class="number">0</span>:</span><br><span class="line">            res += <span class="built_in">str</span>(bits[pos])</span><br><span class="line">            pos -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="29号-1329-将矩阵按对角线排序">29号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-the-matrix-diagonally/">1329. 将矩阵按对角线排序</a></h3>
<p><strong>矩阵对角线</strong> 是一条从矩阵最上面行或者最左侧列中的某个元素开始的对角线，沿右下方向一直到矩阵末尾的元素。例如，矩阵 <code>mat</code> 有 <code>6</code> 行 <code>3</code> 列，从 <code>mat[2][0]</code> 开始的 <strong>矩阵对角线</strong> 将会经过 <code>mat[2][0]</code>、<code>mat[3][1]</code> 和 <code>mat[4][2]</code> 。</p>
<p>给你一个 <code>m * n</code> 的整数矩阵 <code>mat</code> ，请你将同一条 <strong>矩阵对角线</strong> 上的元素按升序排序后，返回排好序的矩阵。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">diagonalSort</span>(<span class="params">self, mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        m, n = <span class="built_in">len</span>(mat), <span class="built_in">len</span>(mat[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> - n, m):  <span class="comment"># k = i - j</span></span><br><span class="line">            left_i, right_i = <span class="built_in">max</span>(k, <span class="number">0</span>), <span class="built_in">min</span>(k + n, m)</span><br><span class="line">            a = <span class="built_in">sorted</span>(mat[i][i - k] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left_i, right_i))</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left_i, right_i):</span><br><span class="line">                mat[i][i - k] = a[i - left_i]</span><br><span class="line">        <span class="keyword">return</span> mat</span><br></pre></td></tr></table></figure>
<h3 id="30号-2798-满足目标工作时长的员工数目">30号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-employees-who-met-the-target/">2798. 满足目标工作时长的员工数目</a></h3>
<p>公司里共有 <code>n</code> 名员工，按从 <code>0</code> 到 <code>n - 1</code> 编号。每个员工 <code>i</code> 已经在公司工作了 <code>hours[i]</code> 小时。</p>
<p>公司要求每位员工工作 <strong>至少</strong> <code>target</code> 小时。</p>
<p>给你一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的非负整数数组 <code>hours</code> 和一个非负整数 <code>target</code> 。</p>
<p>请你用整数表示并返回工作至少 <code>target</code> 小时的员工数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numberOfEmployeesWhoMetTarget</span>(<span class="params">self, hours: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> hour <span class="keyword">in</span> hours:</span><br><span class="line">            <span class="keyword">if</span> hour &gt;= target: res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="5月">5月</h2>
<h3 id="1号-2462-雇佣-K-位工人的总代价">1号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/total-cost-to-hire-k-workers/">2462. 雇佣 K 位工人的总代价</a></h3>
<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>costs</code> ，其中 <code>costs[i]</code> 是雇佣第 <code>i</code> 位工人的代价。</p>
<p>同时给你两个整数 <code>k</code> 和 <code>candidates</code> 。我们想根据以下规则恰好雇佣 <code>k</code> 位工人：</p>
<ul>
<li>总共进行 <code>k</code> 轮雇佣，且每一轮恰好雇佣一位工人。</li>
<li>在每一轮雇佣中，从最前面candidates和最后面candidates人中选出代价最小的一位工人，如果有多位代价相同且最小的工人，选择下标更小的一位工人。
<ul>
<li>比方说，<code>costs = [3,2,7,7,1,2]</code> 且 <code>candidates = 2</code> ，第一轮雇佣中，我们选择第 <code>4</code> 位工人，因为他的代价最小 <code>[*3,2*,7,7,***1**,2*]</code> 。</li>
<li>第二轮雇佣，我们选择第 <code>1</code> 位工人，因为他们的代价与第 <code>4</code> 位工人一样都是最小代价，而且下标更小，<code>[*3,**2***,7,*7,2*]</code> 。注意每一轮雇佣后，剩余工人的下标可能会发生变化。</li>
</ul>
</li>
<li>如果剩余员工数目不足 <code>candidates</code> 人，那么下一轮雇佣他们中代价最小的一人，如果有多位代价相同且最小的工人，选择下标更小的一位工人。</li>
<li>一位工人只能被选择一次。</li>
</ul>
<p>返回雇佣恰好 <code>k</code> 位工人的总代价。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">totalCost</span>(<span class="params">self, costs: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span>, candidates: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(costs)</span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">2</span> * candidates: l, r = candidates, n - candidates </span><br><span class="line">        <span class="keyword">elif</span> n &lt; candidates: l, r = n, n</span><br><span class="line">        <span class="keyword">else</span>: l, r = candidates, candidates</span><br><span class="line">        left = costs[:l]</span><br><span class="line">        right = costs[r:]</span><br><span class="line">        heapq.heapify(left)</span><br><span class="line">        heapq.heapify(right)</span><br><span class="line">        cost = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> k &gt; <span class="number">0</span> <span class="keyword">and</span> l &lt; r:</span><br><span class="line">            <span class="keyword">if</span> left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]:</span><br><span class="line">                cost += heapq.heappop(left)</span><br><span class="line">                heapq.heappush(left,costs[l])</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cost += heapq.heappop(right)</span><br><span class="line">                heapq.heappush(right,costs[r-<span class="number">1</span>])</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> right: cost += heapq.heappop(left)</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> left <span class="keyword">or</span> left[<span class="number">0</span>] &gt; right[<span class="number">0</span>]: cost += heapq.heappop(right)</span><br><span class="line">            <span class="keyword">else</span>: cost += heapq.heappop(left)</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cost</span><br></pre></td></tr></table></figure>
<h3 id="2号-857-雇佣-K-名工人的最低成本">2号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-cost-to-hire-k-workers/">857. 雇佣 K 名工人的最低成本</a></h3>
<p>有 <code>n</code> 名工人。 给定两个数组 <code>quality</code> 和 <code>wage</code> ，其中，<code>quality[i]</code> 表示第 <code>i</code> 名工人的工作质量，其最低期望工资为 <code>wage[i]</code> 。</p>
<p>现在我们想雇佣 <code>k</code> 名工人组成一个*工资组。*在雇佣 一组 <code>k</code> 名工人时，我们必须按照下述规则向他们支付工资：</p>
<ol>
<li>对工资组中的每名工人，应当按其工作质量与同组其他工人的工作质量的比例来支付工资。</li>
<li>工资组中的每名工人至少应当得到他们的最低期望工资。</li>
</ol>
<p>给定整数 <code>k</code> ，返回 <em>组成满足上述条件的付费群体所需的最小金额</em> 。在实际答案的 <code>10-5</code> 以内的答案将被接受。。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mincostToHireWorkers</span>(<span class="params">self, quality: <span class="type">List</span>[<span class="built_in">int</span>], wage: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        pairs = <span class="built_in">sorted</span>(<span class="built_in">zip</span>(quality, wage), key=<span class="keyword">lambda</span> p: p[<span class="number">1</span>] / p[<span class="number">0</span>])  <span class="comment"># 按照 r 值排序</span></span><br><span class="line">        h = [-q <span class="keyword">for</span> q, _ <span class="keyword">in</span> pairs[:k]]  <span class="comment"># 加负号变成最大堆</span></span><br><span class="line">        heapify(h)</span><br><span class="line">        sum_q = -<span class="built_in">sum</span>(h)</span><br><span class="line">        ans = sum_q * pairs[k - <span class="number">1</span>][<span class="number">1</span>] / pairs[k - <span class="number">1</span>][<span class="number">0</span>]  <span class="comment"># 选 r 值最小的 k 名工人</span></span><br><span class="line">        <span class="keyword">for</span> q, w <span class="keyword">in</span> pairs[k:]:  <span class="comment"># 后面的工人 r 值更大</span></span><br><span class="line">            <span class="keyword">if</span> q &lt; -h[<span class="number">0</span>]:  <span class="comment"># 但是 sum_q 可以变小，从而可能得到更优的答案</span></span><br><span class="line">                sum_q += heapreplace(h, -q) + q  <span class="comment"># 更新堆顶和 sum_q</span></span><br><span class="line">                ans = <span class="built_in">min</span>(ans, sum_q * w / q)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="3号-1491-去掉最低工资和最高工资后的工资平均值">3号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/average-salary-excluding-the-minimum-and-maximum-salary/">1491. 去掉最低工资和最高工资后的工资平均值</a></h3>
<p>给你一个整数数组 <code>salary</code> ，数组里每个数都是 <strong>唯一</strong> 的，其中 <code>salary[i]</code> 是第 <code>i</code> 个员工的工资。</p>
<p>请你返回去掉最低工资和最高工资以后，剩下员工工资的平均值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">average</span>(<span class="params">self, salary: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        s = <span class="built_in">sum</span>(salary)</span><br><span class="line">        M = <span class="built_in">max</span>(salary)</span><br><span class="line">        m = <span class="built_in">min</span>(salary)</span><br><span class="line">        n = <span class="built_in">len</span>(salary)</span><br><span class="line">        <span class="keyword">return</span> (s - M - m) / (n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h3 id="4号-1235-规划兼职工作">4号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-profit-in-job-scheduling/">1235. 规划兼职工作</a></h3>
<p>你打算利用空闲时间来做兼职工作赚些零花钱。</p>
<p>这里有 <code>n</code> 份兼职工作，每份工作预计从 <code>startTime[i]</code> 开始到 <code>endTime[i]</code> 结束，报酬为 <code>profit[i]</code>。</p>
<p>给你一份兼职工作表，包含开始时间 <code>startTime</code>，结束时间 <code>endTime</code> 和预计报酬 <code>profit</code> 三个数组，请你计算并返回可以获得的最大报酬。</p>
<p>注意，时间上出现重叠的 2 份工作不能同时进行。</p>
<p>如果你选择的工作在时间 <code>X</code> 结束，那么你可以立刻进行在时间 <code>X</code> 开始的下一份工作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">jobScheduling</span>(<span class="params">self, startTime: <span class="type">List</span>[<span class="built_in">int</span>], endTime: <span class="type">List</span>[<span class="built_in">int</span>], profit: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        jobs = <span class="built_in">sorted</span>(<span class="built_in">zip</span>(endTime, startTime, profit))  <span class="comment"># 按照结束时间排序</span></span><br><span class="line">        f = [<span class="number">0</span>] * (<span class="built_in">len</span>(jobs) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i, (_, st, p) <span class="keyword">in</span> <span class="built_in">enumerate</span>(jobs):</span><br><span class="line">            j = bisect_left(jobs, (st + <span class="number">1</span>,), hi=i)  <span class="comment"># hi=i 表示二分上界为 i（默认为 n）</span></span><br><span class="line">            <span class="comment"># 状态转移中，为什么是 j 不是 j+1：上面算的是 &gt; st，-1 后得到 &lt;= st，但由于还要 +1，抵消了</span></span><br><span class="line">            f[i + <span class="number">1</span>] = <span class="built_in">max</span>(f[i], f[j] + p)</span><br><span class="line">        <span class="keyword">return</span> f[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="5号-1652-拆炸弹">5号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/defuse-the-bomb/">1652. 拆炸弹</a></h3>
<p>你有一个炸弹需要拆除，时间紧迫！你的情报员会给你一个长度为 <code>n</code> 的 <strong>循环</strong> 数组 <code>code</code> 以及一个密钥 <code>k</code> 。</p>
<p>为了获得正确的密码，你需要替换掉每一个数字。所有数字会 <strong>同时</strong> 被替换。</p>
<ul>
<li>如果 <code>k &gt; 0</code> ，将第 <code>i</code> 个数字用 <strong>接下来</strong> <code>k</code> 个数字之和替换。</li>
<li>如果 <code>k &lt; 0</code> ，将第 <code>i</code> 个数字用 <strong>之前</strong> <code>k</code> 个数字之和替换。</li>
<li>如果 <code>k == 0</code> ，将第 <code>i</code> 个数字用 <code>0</code> 替换。</li>
</ul>
<p>由于 <code>code</code> 是循环的， <code>code[n-1]</code> 下一个元素是 <code>code[0]</code> ，且 <code>code[0]</code> 前一个元素是 <code>code[n-1]</code> 。</p>
<p>给你 <strong>循环</strong> 数组 <code>code</code> 和整数密钥 <code>k</code> ，请你返回解密后的结果来拆除炸弹！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">self, code: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(code)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            code = code + code[:k]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n): res.append(<span class="built_in">sum</span>(code[i+<span class="number">1</span>:i+k+<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">elif</span> k &lt; <span class="number">0</span>:</span><br><span class="line">            code = code[n+k:] + code</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(-k,n-k): res.append(<span class="built_in">sum</span>(code[i+k:i]))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="6号-741-摘樱桃">6号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cherry-pickup/">741. 摘樱桃</a></h3>
<p>给你一个 <code>n x n</code> 的网格 <code>grid</code> ，代表一块樱桃地，每个格子由以下三种数字的一种来表示：</p>
<ul>
<li><code>0</code> 表示这个格子是空的，所以你可以穿过它。</li>
<li><code>1</code> 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。</li>
<li><code>-1</code> 表示这个格子里有荆棘，挡着你的路。</li>
</ul>
<p>请你统计并返回：在遵守下列规则的情况下，能摘到的最多樱桃数：</p>
<ul>
<li>从位置 <code>(0, 0)</code> 出发，最后到达 <code>(n - 1, n - 1)</code> ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为 <code>0</code> 或者 <code>1</code> 的格子）；</li>
<li>当到达 <code>(n - 1, n - 1)</code> 后，你要继续走，直到返回到 <code>(0, 0) </code>，只能向上或向左走，并且只能穿越有效的格子；</li>
<li>当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为 <code>0</code> ）；</li>
<li>如果在 <code>(0, 0)</code> 和 <code>(n - 1, n - 1)</code> 之间不存在一条可经过的路径，则无法摘到任何一个樱桃。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cherryPickup</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"><span class="meta">        @cache  </span><span class="comment"># 缓存装饰器，避免重复计算 dfs 的结果（记忆化）</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">t: <span class="built_in">int</span>, j: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="comment"># 不能出界，不能访问 -1 格子</span></span><br><span class="line">            <span class="keyword">if</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> k &lt; <span class="number">0</span> <span class="keyword">or</span> t &lt; j <span class="keyword">or</span> t &lt; k <span class="keyword">or</span> grid[t - j][j] &lt; <span class="number">0</span> <span class="keyword">or</span> grid[t - k][k] &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> -inf</span><br><span class="line">            <span class="keyword">if</span> t == <span class="number">0</span>:  <span class="comment"># 此时 j = k = 0</span></span><br><span class="line">                <span class="keyword">return</span> grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(dfs(t - <span class="number">1</span>, j, k), dfs(t - <span class="number">1</span>, j, k - <span class="number">1</span>), dfs(t - <span class="number">1</span>, j - <span class="number">1</span>, k), dfs(t - <span class="number">1</span>, j - <span class="number">1</span>, k - <span class="number">1</span>)) + \</span><br><span class="line">                grid[t - j][j] + (grid[t - k][k] <span class="keyword">if</span> k != j <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">        n = <span class="built_in">len</span>(grid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dfs(n * <span class="number">2</span> - <span class="number">2</span>, n - <span class="number">1</span>, n - <span class="number">1</span>), <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>7号_<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cherry-pickup-ii/">1463. 摘樱桃 II</a></p>
<p>给你一个 <code>rows x cols</code> 的矩阵 <code>grid</code> 来表示一块樱桃地。 <code>grid</code> 中每个格子的数字表示你能获得的樱桃数目。</p>
<p>你有两个机器人帮你收集樱桃，机器人 1 从左上角格子 <code>(0,0)</code> 出发，机器人 2 从右上角格子 <code>(0, cols-1)</code> 出发。</p>
<p>请你按照如下规则，返回两个机器人能收集的最多樱桃数目：</p>
<ul>
<li>从格子 <code>(i,j)</code> 出发，机器人可以移动到格子 <code>(i+1, j-1)</code>，<code>(i+1, j)</code> 或者 <code>(i+1, j+1)</code> 。</li>
<li>当一个机器人经过某个格子时，它会把该格子内所有的樱桃都摘走，然后这个位置会变成空格子，即没有樱桃的格子。</li>
<li>当两个机器人同时到达同一个格子时，它们中只有一个可以摘到樱桃。</li>
<li>两个机器人在任意时刻都不能移动到 <code>grid</code> 外面。</li>
<li>两个机器人最后都要到达 <code>grid</code> 最底下一行。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cherryPickup</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"><span class="meta">        @cache  </span><span class="comment"># 缓存装饰器，避免重复计算 dfs 的结果（记忆化）</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i: <span class="built_in">int</span>, j: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> i == m <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= n <span class="keyword">or</span> k &lt; <span class="number">0</span> <span class="keyword">or</span> k &gt;= n:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(dfs(i + <span class="number">1</span>, j2, k2) <span class="keyword">for</span> j2 <span class="keyword">in</span> (j - <span class="number">1</span>, j, j + <span class="number">1</span>) <span class="keyword">for</span> k2 <span class="keyword">in</span> (k - <span class="number">1</span>, k, k + <span class="number">1</span>)) + \</span><br><span class="line">                   grid[i][j] + (grid[i][k] <span class="keyword">if</span> k != j <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h1>2025年</h1>
<h2 id="2月">2月</h2>
<p>20号 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-even-and-odd-bits/">2595. 奇偶位数</a></p>
<p>给你一个 <strong>正</strong> 整数 <code>n</code> 。</p>
<p>用 <code>even</code> 表示在 <code>n</code> 的二进制形式（下标从 <strong>0</strong> 开始）中值为 <code>1</code> 的偶数下标的个数。</p>
<p>用 <code>odd</code> 表示在 <code>n</code> 的二进制形式（下标从 <strong>0</strong> 开始）中值为 <code>1</code> 的奇数下标的个数。</p>
<p>请注意，在数字的二进制表示中，位下标的顺序 <strong>从右到左</strong>。</p>
<p>返回整数数组 <code>answer</code> ，其中 <code>answer = [even, odd]</code> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">evenOddBit</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        even, odd = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">2</span>: even += <span class="number">1</span></span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">2</span>: odd += <span class="number">1</span></span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [even,odd]</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://anym0re.cn">anym0re</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://anym0re.cn/2024/03/03/leetcode-everyday/">http://anym0re.cn/2024/03/03/leetcode-everyday/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://anym0re.cn" target="_blank">陪小付度过漫长岁月</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BB%A3%E7%A0%81/">代码</a><a class="post-meta__tags" href="/tags/python/">python</a><a class="post-meta__tags" href="/tags/leetcode/">leetcode</a><a class="post-meta__tags" href="/tags/csdn/">csdn</a></div><div class="post-share"><div class="social-share" data-image="https://s2.loli.net/2024/02/25/zIWeRaZnF8Vxsqv.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/03/03/leetcode-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="leetcode-数据结构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">leetcode-数据结构</div></div><div class="info-2"><div class="info-item-1">链表 链表以节点为单位，每个元素都是一个独立对象，在内存空间的存储是非连续的。链表的节点对象具有两个成员变量：「值 val」，「后继节点引用 next」 。 1234class ListNode:    def __init__(self, x):        self.val = x     # 节点值        self.next = None # 后继节点引用 如下图所示，建立此链表需要实例化每个节点，并构建各节点的引用指向。 12345678# 实例化节点n1 = ListNode(4) # 节点 headn2 = ListNode(5)n3 = ListNode(1)# 构建引用指向n1.next = n2n2.next = n3  图书整理 I 书店店员有一张链表形式的书单，每个节点代表一本书，节点中的值表示书的编号。为更方便整理书架，店员需要将书单倒过来排列，就可以从最后一本书开始整理，逐一将书放回到书架上。请倒序返回这个书单链表。 12345678910111213# Definition for singly-linked list.# class Lis...</div></div></div></a><a class="pagination-related" href="/2024/03/03/Binary%20tree/" title="二叉树相关知识点"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">二叉树相关知识点</div></div><div class="info-2"><div class="info-item-1">二叉树的一些概念 二叉树_百度百科  二叉树（Binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。二叉树特点是每个节点最多只能有两棵子树，且有左右之分。 二叉树是n个有限元素的集合，该集合或者为空、或者由一个称为根（root）的元素及两个不相交的、被分别称为左子树和右子树的二叉树组成，是有序树。当集合为空时，称该二叉树为空二叉树。在二叉树中，一个元素也称作一个节点。  二叉树知识点最详细最全讲解  把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点： 1.每个节点有零个或多个子节点; 2.没有父节点的节点称为根节点; 3.每一个非跟节点有且仅有一个父节点; 4.除了根节点以外，每个子节点可以分为多个不想交的子树。   节点的度:节点拥有的子树的数目。 叶子:度为零的节点。 分支节点:度不为零的节点。 树的度:树中节点的最大的度 层次:根节点的层次为1，其余节点的层次等于该节点的双亲节点加1。 ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/03/03/leetcode-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="leetcode-数据结构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-03</div><div class="info-item-2">leetcode-数据结构</div></div><div class="info-2"><div class="info-item-1">链表 链表以节点为单位，每个元素都是一个独立对象，在内存空间的存储是非连续的。链表的节点对象具有两个成员变量：「值 val」，「后继节点引用 next」 。 1234class ListNode:    def __init__(self, x):        self.val = x     # 节点值        self.next = None # 后继节点引用 如下图所示，建立此链表需要实例化每个节点，并构建各节点的引用指向。 12345678# 实例化节点n1 = ListNode(4) # 节点 headn2 = ListNode(5)n3 = ListNode(1)# 构建引用指向n1.next = n2n2.next = n3  图书整理 I 书店店员有一张链表形式的书单，每个节点代表一本书，节点中的值表示书的编号。为更方便整理书架，店员需要将书单倒过来排列，就可以从最后一本书开始整理，逐一将书放回到书架上。请倒序返回这个书单链表。 12345678910111213# Definition for singly-linked list.# class Lis...</div></div></div></a><a class="pagination-related" href="/2024/02/28/leetcode-hard/" title="leetcode困难题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-28</div><div class="info-item-2">leetcode困难题</div></div><div class="info-2"><div class="info-item-1">10. 正则表达式匹配 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。  '.' 匹配任意单个字符 '*' 匹配零个或多个前面的那一个元素  所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 12345678910111213141516171819#动态规划class Solution:    def isMatch(self, s: str, p: str) -&gt; bool:        s, p = &#x27;0&#x27;+s, &#x27;0&#x27;+p   #用&#x27;0&#x27;来代替&#x27;&#x27;，使得题解更清晰        m, n = len(s), len(p)        #dp[i][j]表明s[:i+1]是否与p[:j+1]匹配，因为我们前面加上了&#x27;0&#x27;，所以这里dp[i][j]与s[i],p[j]关联        dp = [[False ] * n for _ in range(m)]          dp[0][0] = Tru...</div></div></div></a><a class="pagination-related" href="/2024/02/28/leetcode-medium/" title="leetcode中等题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-28</div><div class="info-item-2">leetcode中等题</div></div><div class="info-2"><div class="info-item-1">2. 两数相加 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 1234567891011121314151617181920212223242526272829303132# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:        num_l1=num_l2=0        # l1_p,l2_p=l1,l2，题解中定义...</div></div></div></a><a class="pagination-related" href="/2024/02/26/leetcode-easy/" title="leetcode简单题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-26</div><div class="info-item-2">leetcode简单题</div></div><div class="info-2"><div class="info-item-1">1. 两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案 123456class Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        for i in range(len(nums)):               for j in range(i+1,len(nums)):  #两数不重复                if nums[i]+nums[j]==target:                    return([i,j]) 9. 回文数 给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 例如，121 是回文，而 123 不是。 12...</div></div></div></a><a class="pagination-related" href="/2024/04/05/hot100/" title="leetcode-hot100"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-05</div><div class="info-item-2">leetcode-hot100</div></div><div class="info-2"><div class="info-item-1">哈希 1. 两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 1234567#穷举class Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        n = len(nums)        for i in range(n):            for j in range(i+1,n):                if nums[i] + nums[j] == target: return [i,j] 1234567#哈希表class Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        mp = &#123;&#125;     ...</div></div></div></a><a class="pagination-related" href="/2024/03/10/leetcode-%E5%91%A8%E8%B5%9B/" title="leetcode周赛"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-10</div><div class="info-item-2">leetcode周赛</div></div><div class="info-2"><div class="info-item-1">第388场周赛（模拟参赛） 100233. 重新分装苹果 给你一个长度为 n 的数组 apple 和另一个长度为 m 的数组 capacity 。 一共有 n 个包裹，其中第 i 个包裹中装着 apple[i] 个苹果。同时，还有 m 个箱子，第 i 个箱子的容量为 capacity[i] 个苹果。 请你选择一些箱子来将这 n 个包裹中的苹果重新分装到箱子中，返回你需要选择的箱子的 最小 数量。 注意，同一个包裹中的苹果可以分装到不同的箱子中 12345678class Solution:    def minimumBoxes(self, apple: List[int], capacity: List[int]) -&gt; int:        capacity.sort(reverse=True)        s = sum(apple)        for i,item in enumerate(capacity):            s -= item            if s &lt;= 0:                return i+1 10...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://s2.loli.net/2024/02/25/zIWeRaZnF8Vxsqv.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">anym0re</div><div class="author-info-description">送给小付的情书</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/linmu130"><i class="fab fa-github"></i><span>关注我的Github</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/linmu130" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:13020037606@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客，这里用作anym0re记录自己的工作和生活，可以在左下角切歌或关闭音乐，欢迎留言评论。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">2024年</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E6%9C%88"><span class="toc-number">1.1.</span> <span class="toc-text">3月</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%8F%B7-2369-%E6%A3%80%E6%9F%A5%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%9C%89%E6%95%88%E5%88%92%E5%88%86"><span class="toc-number">1.1.1.</span> <span class="toc-text">1号_2369. 检查数组是否存在有效划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%8F%B7-2368-%E5%8F%97%E9%99%90%E6%9D%A1%E4%BB%B6%E4%B8%8B%E5%8F%AF%E5%88%B0%E8%BE%BE%E8%8A%82%E7%82%B9%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">1.1.2.</span> <span class="toc-text">2号_2368. 受限条件下可到达节点的数目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E5%8F%B7-225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="toc-number">1.1.3.</span> <span class="toc-text">3号_225. 用队列实现栈</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E5%8F%B7-232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">2.0.1.</span> <span class="toc-text">4号_232. 用栈实现队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E5%8F%B7-1976-%E5%88%B0%E8%BE%BE%E7%9B%AE%E7%9A%84%E5%9C%B0%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0"><span class="toc-number">2.0.2.</span> <span class="toc-text">5号_1976.到达目的地的方案数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E5%8F%B7-2917-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84-K-or-%E5%80%BC"><span class="toc-number">2.0.3.</span> <span class="toc-text">6号_2917. 找出数组中的 K-or 值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E5%8F%B7-2575-%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8F%AF%E6%95%B4%E9%99%A4%E6%95%B0%E7%BB%84"><span class="toc-number">2.0.4.</span> <span class="toc-text">7号_2575. 找出字符串的可整除数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E5%8F%B7-2834-%E6%89%BE%E5%87%BA%E7%BE%8E%E4%B8%BD%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%92%8C"><span class="toc-number">2.0.5.</span> <span class="toc-text">8号_2834. 找出美丽数组的最小和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E5%8F%B7-2386-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E7%9A%84%E7%AC%AC-K-%E5%A4%A7%E5%92%8C"><span class="toc-number">2.0.6.</span> <span class="toc-text">9号_2386. 找出数组的第 K 大和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E5%8F%B7-299-%E7%8C%9C%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F"><span class="toc-number">2.0.7.</span> <span class="toc-text">10号_299. 猜数字游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E5%8F%B7-2129-%E5%B0%86%E6%A0%87%E9%A2%98%E9%A6%96%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%86%99"><span class="toc-number">2.0.8.</span> <span class="toc-text">11号_2129. 将标题首字母大写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E5%8F%B7-1261-%E5%9C%A8%E5%8F%97%E6%B1%A1%E6%9F%93%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0"><span class="toc-number">2.0.9.</span> <span class="toc-text">12号_1261. 在受污染的二叉树中查找元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E5%8F%B7-2864-%E6%9C%80%E5%A4%A7%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%A5%87%E6%95%B0"><span class="toc-number">2.0.10.</span> <span class="toc-text">13号_2864. 最大二进制奇数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E5%8F%B7-2789-%E5%90%88%E5%B9%B6%E5%90%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="toc-number">2.0.11.</span> <span class="toc-text">14号_2789. 合并后数组中的最大元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E5%8F%B7-2312-%E5%8D%96%E6%9C%A8%E5%A4%B4%E5%9D%97"><span class="toc-number">2.0.12.</span> <span class="toc-text">15号_2312. 卖木头块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E5%8F%B7-2684-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%A7%BB%E5%8A%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E6%AC%A1%E6%95%B0"><span class="toc-number">2.0.13.</span> <span class="toc-text">16号_2684. 矩阵中移动的最大次数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17%E5%8F%B7-310-%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91"><span class="toc-number">2.0.14.</span> <span class="toc-text">17号_310. 最小高度树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%E5%8F%B7-303-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-number">2.0.15.</span> <span class="toc-text">18号_303. 区域和检索 - 数组不可变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19%E5%8F%B7-1793-%E5%A5%BD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0"><span class="toc-number">2.0.16.</span> <span class="toc-text">19号_1793. 好子数组的最大分数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21%E5%8F%B7-2671-%E9%A2%91%E7%8E%87%E8%B7%9F%E8%B8%AA%E5%99%A8"><span class="toc-number">2.0.17.</span> <span class="toc-text">21号_2671. 频率跟踪器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E5%8F%B7-2617-%E7%BD%91%E6%A0%BC%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%B0%91%E8%AE%BF%E9%97%AE%E7%9A%84%E6%A0%BC%E5%AD%90%E6%95%B0"><span class="toc-number">2.0.18.</span> <span class="toc-text">22号_2617. 网格图中最少访问的格子数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23%E5%8F%B7-2549-%E7%BB%9F%E8%AE%A1%E6%A1%8C%E9%9D%A2%E4%B8%8A%E7%9A%84%E4%B8%8D%E5%90%8C%E6%95%B0%E5%AD%97"><span class="toc-number">2.0.19.</span> <span class="toc-text">23号_2549. 统计桌面上的不同数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24%E5%8F%B7-322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="toc-number">2.0.20.</span> <span class="toc-text">24号_322. 零钱兑换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25%E5%8F%B7-518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-II"><span class="toc-number">2.0.21.</span> <span class="toc-text">25号_518. 零钱兑换 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26%E5%8F%B7-2642-%E8%AE%BE%E8%AE%A1%E5%8F%AF%E4%BB%A5%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%9A%84%E5%9B%BE%E7%B1%BB"><span class="toc-number">2.0.22.</span> <span class="toc-text">26号_2642. 设计可以求最短路径的图类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27%E5%8F%B7-2580-%E7%BB%9F%E8%AE%A1%E5%B0%86%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6%E6%88%90%E7%BB%84%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0"><span class="toc-number">2.0.23.</span> <span class="toc-text">27号_2580. 统计将重叠区间合并成组的方案数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28%E5%8F%B7-1997-%E8%AE%BF%E9%97%AE%E5%AE%8C%E6%89%80%E6%9C%89%E6%88%BF%E9%97%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9"><span class="toc-number">2.0.24.</span> <span class="toc-text">28号_1997. 访问完所有房间的第一天</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29%E5%8F%B7-2908-%E5%85%83%E7%B4%A0%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84%E5%B1%B1%E5%BD%A2%E4%B8%89%E5%85%83%E7%BB%84-I"><span class="toc-number">2.0.25.</span> <span class="toc-text">29号_2908. 元素和最小的山形三元组 I</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30%E5%8F%B7-2952-%E9%9C%80%E8%A6%81%E6%B7%BB%E5%8A%A0%E7%9A%84%E7%A1%AC%E5%B8%81%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E9%87%8F"><span class="toc-number">2.0.26.</span> <span class="toc-text">30号_2952. 需要添加的硬币的最小数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31%E5%8F%B7-331-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">2.0.27.</span> <span class="toc-text">31号_331. 验证二叉树的前序序列化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E6%9C%88"><span class="toc-number">2.1.</span> <span class="toc-text">4月</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%8F%B7-2810-%E6%95%85%E9%9A%9C%E9%94%AE%E7%9B%98"><span class="toc-number">2.1.1.</span> <span class="toc-text">1号_2810. 故障键盘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%8F%B7-894-%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E7%9C%9F%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.1.2.</span> <span class="toc-text">2号_894. 所有可能的真二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E5%8F%B7-1379-%E6%89%BE%E5%87%BA%E5%85%8B%E9%9A%86%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%90%8C%E8%8A%82%E7%82%B9"><span class="toc-number">2.1.3.</span> <span class="toc-text">3号_1379. 找出克隆二叉树中的相同节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E5%8F%B7-2192-%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E4%B8%AD%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%89%80%E6%9C%89%E7%A5%96%E5%85%88"><span class="toc-number">2.1.4.</span> <span class="toc-text">4号_2192. 有向无环图中一个节点的所有祖先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E5%8F%B7-1026-%E8%8A%82%E7%82%B9%E4%B8%8E%E5%85%B6%E7%A5%96%E5%85%88%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC"><span class="toc-number">2.1.5.</span> <span class="toc-text">5号_1026. 节点与其祖先之间的最大差值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E5%8F%B7-1483-%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84%E7%AC%AC-K-%E4%B8%AA%E7%A5%96%E5%85%88"><span class="toc-number">2.1.6.</span> <span class="toc-text">6号_1483. 树节点的第 K 个祖先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E5%8F%B7-1600-%E7%8E%8B%E4%BD%8D%E7%BB%A7%E6%89%BF%E9%A1%BA%E5%BA%8F"><span class="toc-number">2.1.7.</span> <span class="toc-text">7号_1600. 王位继承顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E5%8F%B7-2009-%E4%BD%BF%E6%95%B0%E7%BB%84%E8%BF%9E%E7%BB%AD%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%95%B0"><span class="toc-number">2.1.8.</span> <span class="toc-text">8号_2009. 使数组连续的最少操作数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E5%8F%B7-2529-%E6%AD%A3%E6%95%B4%E6%95%B0%E5%92%8C%E8%B4%9F%E6%95%B4%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E8%AE%A1%E6%95%B0"><span class="toc-number">2.1.9.</span> <span class="toc-text">9号_2529. 正整数和负整数的最大计数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E5%8F%B7-1702-%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.1.10.</span> <span class="toc-text">10号_1702. 修改后的最大二进制字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E5%8F%B7-1766-%E4%BA%92%E8%B4%A8%E6%A0%91"><span class="toc-number">2.1.11.</span> <span class="toc-text">11号_1766. 互质树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E5%8F%B7-2923-%E6%89%BE%E5%88%B0%E5%86%A0%E5%86%9B-I"><span class="toc-number">2.1.12.</span> <span class="toc-text">12号__2923. 找到冠军 I</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E5%8F%B7-2924-%E6%89%BE%E5%88%B0%E5%86%A0%E5%86%9B-II"><span class="toc-number">2.1.13.</span> <span class="toc-text">13号_2924. 找到冠军 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E5%8F%B7-705-%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88"><span class="toc-number">2.1.14.</span> <span class="toc-text">14号_705. 设计哈希集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E5%8F%B7-706-%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84"><span class="toc-number">2.1.15.</span> <span class="toc-text">15号_706. 设计哈希映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E5%8F%B7-924-%E5%B0%BD%E9%87%8F%E5%87%8F%E5%B0%91%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E7%9A%84%E4%BC%A0%E6%92%AD"><span class="toc-number">2.1.16.</span> <span class="toc-text">16号_924. 尽量减少恶意软件的传播</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17%E5%8F%B7-928-%E5%B0%BD%E9%87%8F%E5%87%8F%E5%B0%91%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E7%9A%84%E4%BC%A0%E6%92%AD-II"><span class="toc-number">2.1.17.</span> <span class="toc-text">17号__928. 尽量减少恶意软件的传播 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%E5%8F%B7-2007-%E4%BB%8E%E5%8F%8C%E5%80%8D%E6%95%B0%E7%BB%84%E4%B8%AD%E8%BF%98%E5%8E%9F%E5%8E%9F%E6%95%B0%E7%BB%84"><span class="toc-number">2.1.18.</span> <span class="toc-text">18号_2007. 从双倍数组中还原原数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19%E5%8F%B7-1883-%E5%87%86%E6%97%B6%E6%8A%B5%E8%BE%BE%E4%BC%9A%E8%AE%AE%E7%8E%B0%E5%9C%BA%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%B3%E8%BF%87%E4%BC%91%E6%81%AF%E6%AC%A1%E6%95%B0"><span class="toc-number">2.1.19.</span> <span class="toc-text">19号_1883. 准时抵达会议现场的最小跳过休息次数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20%E5%8F%B7-39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-number">2.1.20.</span> <span class="toc-text">20号_39. 组合总和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21%E5%8F%B7-216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III"><span class="toc-number">2.1.21.</span> <span class="toc-text">21号_216. 组合总和 III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E5%8F%B7-377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E2%85%A3"><span class="toc-number">2.1.22.</span> <span class="toc-text">22号_377. 组合总和 Ⅳ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-1052-%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF"><span class="toc-number">2.1.23.</span> <span class="toc-text">23_1052. 爱生气的书店老板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24%E5%8F%B7-2385-%E6%84%9F%E6%9F%93%E4%BA%8C%E5%8F%89%E6%A0%91%E9%9C%80%E8%A6%81%E7%9A%84%E6%80%BB%E6%97%B6%E9%97%B4"><span class="toc-number">2.1.24.</span> <span class="toc-text">24号_2385. 感染二叉树需要的总时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25%E5%8F%B7-2739-%E6%80%BB%E8%A1%8C%E9%A9%B6%E8%B7%9D%E7%A6%BB"><span class="toc-number">2.1.25.</span> <span class="toc-text">25号_2739. 总行驶距离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26%E5%8F%B7-1146-%E5%BF%AB%E7%85%A7%E6%95%B0%E7%BB%84"><span class="toc-number">2.1.26.</span> <span class="toc-text">26号_1146. 快照数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28%E5%8F%B7-1017-%E8%B4%9F%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.1.27.</span> <span class="toc-text">28号_1017. 负二进制转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29%E5%8F%B7-1329-%E5%B0%86%E7%9F%A9%E9%98%B5%E6%8C%89%E5%AF%B9%E8%A7%92%E7%BA%BF%E6%8E%92%E5%BA%8F"><span class="toc-number">2.1.28.</span> <span class="toc-text">29号_1329. 将矩阵按对角线排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30%E5%8F%B7-2798-%E6%BB%A1%E8%B6%B3%E7%9B%AE%E6%A0%87%E5%B7%A5%E4%BD%9C%E6%97%B6%E9%95%BF%E7%9A%84%E5%91%98%E5%B7%A5%E6%95%B0%E7%9B%AE"><span class="toc-number">2.1.29.</span> <span class="toc-text">30号_2798. 满足目标工作时长的员工数目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E6%9C%88"><span class="toc-number">2.2.</span> <span class="toc-text">5月</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%8F%B7-2462-%E9%9B%87%E4%BD%A3-K-%E4%BD%8D%E5%B7%A5%E4%BA%BA%E7%9A%84%E6%80%BB%E4%BB%A3%E4%BB%B7"><span class="toc-number">2.2.1.</span> <span class="toc-text">1号_2462. 雇佣 K 位工人的总代价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%8F%B7-857-%E9%9B%87%E4%BD%A3-K-%E5%90%8D%E5%B7%A5%E4%BA%BA%E7%9A%84%E6%9C%80%E4%BD%8E%E6%88%90%E6%9C%AC"><span class="toc-number">2.2.2.</span> <span class="toc-text">2号_857. 雇佣 K 名工人的最低成本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E5%8F%B7-1491-%E5%8E%BB%E6%8E%89%E6%9C%80%E4%BD%8E%E5%B7%A5%E8%B5%84%E5%92%8C%E6%9C%80%E9%AB%98%E5%B7%A5%E8%B5%84%E5%90%8E%E7%9A%84%E5%B7%A5%E8%B5%84%E5%B9%B3%E5%9D%87%E5%80%BC"><span class="toc-number">2.2.3.</span> <span class="toc-text">3号_1491. 去掉最低工资和最高工资后的工资平均值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E5%8F%B7-1235-%E8%A7%84%E5%88%92%E5%85%BC%E8%81%8C%E5%B7%A5%E4%BD%9C"><span class="toc-number">2.2.4.</span> <span class="toc-text">4号_1235. 规划兼职工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E5%8F%B7-1652-%E6%8B%86%E7%82%B8%E5%BC%B9"><span class="toc-number">2.2.5.</span> <span class="toc-text">5号_1652. 拆炸弹</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E5%8F%B7-741-%E6%91%98%E6%A8%B1%E6%A1%83"><span class="toc-number">2.2.6.</span> <span class="toc-text">6号_741. 摘樱桃</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">2025年</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E6%9C%88"><span class="toc-number">3.1.</span> <span class="toc-text">2月</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/11/%E9%9D%A2%E8%AF%95/" title="面试">面试</a><time datetime="2024-04-11T07:20:34.000Z" title="发表于 2024-04-11 15:20:34">2024-04-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/05/hot100/" title="leetcode-hot100">leetcode-hot100</a><time datetime="2024-04-05T04:25:58.000Z" title="发表于 2024-04-05 12:25:58">2024-04-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/31/%E7%AC%94%E8%AF%95/" title="实习生笔试">实习生笔试</a><time datetime="2024-03-31T04:56:31.000Z" title="发表于 2024-03-31 12:56:31">2024-03-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/28/offer/" title="剑指offer">剑指offer</a><time datetime="2024-03-28T02:44:52.000Z" title="发表于 2024-03-28 10:44:52">2024-03-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/19/d2l/" title="在李沐大神d2l中踩过的坑">在李沐大神d2l中踩过的坑</a><time datetime="2024-03-19T08:56:17.000Z" title="发表于 2024-03-19 16:56:17">2024-03-19</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2024 - 2025 By anym0re</span></div><div class="footer_custom_text">陪伴是最长情的告白</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.4.3"></script><script src="/js/main.js?v=5.4.3"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://linmu130-anym0re.hf.space',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://linmu130-anym0re.hf.space',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.44/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script src="/js/sakura.js"></script><div class="aplayer no-destroy" data-id="614635824" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/fireworks.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>